/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_encoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_decoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event_decoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_query_decoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_insn_decoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_block_decoder {
    _unused: [u8; 0],
}
#[doc = " The library version."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_version {
    #[doc = " Major version number."]
    pub major: u8,
    #[doc = " Minor version number."]
    pub minor: u8,
    #[doc = " Patch level."]
    pub patch: u16,
    #[doc = " Build number."]
    pub build: u32,
    #[doc = " Version extension."]
    pub ext: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_version"][::std::mem::size_of::<pt_version>() - 16usize];
    ["Alignment of pt_version"][::std::mem::align_of::<pt_version>() - 8usize];
    ["Offset of field: pt_version::major"][::std::mem::offset_of!(pt_version, major) - 0usize];
    ["Offset of field: pt_version::minor"][::std::mem::offset_of!(pt_version, minor) - 1usize];
    ["Offset of field: pt_version::patch"][::std::mem::offset_of!(pt_version, patch) - 2usize];
    ["Offset of field: pt_version::build"][::std::mem::offset_of!(pt_version, build) - 4usize];
    ["Offset of field: pt_version::ext"][::std::mem::offset_of!(pt_version, ext) - 8usize];
};
extern "C" {
    #[doc = " Return the library version."]
    pub fn pt_library_version() -> pt_version;
}
pub const pt_error_code_pte_ok: pt_error_code = 0;
pub const pt_error_code_pte_internal: pt_error_code = 1;
pub const pt_error_code_pte_invalid: pt_error_code = 2;
pub const pt_error_code_pte_nosync: pt_error_code = 3;
pub const pt_error_code_pte_bad_opc: pt_error_code = 4;
pub const pt_error_code_pte_bad_packet: pt_error_code = 5;
pub const pt_error_code_pte_bad_context: pt_error_code = 6;
pub const pt_error_code_pte_eos: pt_error_code = 7;
pub const pt_error_code_pte_bad_query: pt_error_code = 8;
pub const pt_error_code_pte_nomem: pt_error_code = 9;
pub const pt_error_code_pte_bad_config: pt_error_code = 10;
pub const pt_error_code_pte_noip: pt_error_code = 11;
pub const pt_error_code_pte_ip_suppressed: pt_error_code = 12;
pub const pt_error_code_pte_nomap: pt_error_code = 13;
pub const pt_error_code_pte_bad_insn: pt_error_code = 14;
pub const pt_error_code_pte_no_time: pt_error_code = 15;
pub const pt_error_code_pte_no_cbr: pt_error_code = 16;
pub const pt_error_code_pte_bad_image: pt_error_code = 17;
pub const pt_error_code_pte_bad_lock: pt_error_code = 18;
pub const pt_error_code_pte_not_supported: pt_error_code = 19;
pub const pt_error_code_pte_retstack_empty: pt_error_code = 20;
pub const pt_error_code_pte_bad_retcomp: pt_error_code = 21;
pub const pt_error_code_pte_bad_status_update: pt_error_code = 22;
pub const pt_error_code_pte_no_enable: pt_error_code = 23;
pub const pt_error_code_pte_event_ignored: pt_error_code = 24;
pub const pt_error_code_pte_overflow: pt_error_code = 25;
pub const pt_error_code_pte_bad_file: pt_error_code = 26;
pub const pt_error_code_pte_bad_cpu: pt_error_code = 27;
#[doc = " Error codes."]
pub type pt_error_code = i32;
extern "C" {
    #[doc = " Return a human readable error string."]
    pub fn pt_errstr(arg1: pt_error_code) -> *const ::std::os::raw::c_char;
}
pub const pt_cpu_vendor_pcv_unknown: pt_cpu_vendor = 0;
pub const pt_cpu_vendor_pcv_intel: pt_cpu_vendor = 1;
#[doc = " A cpu vendor."]
pub type pt_cpu_vendor = i32;
#[doc = " A cpu identifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_cpu {
    #[doc = " The cpu vendor."]
    pub vendor: pt_cpu_vendor,
    #[doc = " The cpu family."]
    pub family: u16,
    #[doc = " The cpu model."]
    pub model: u8,
    #[doc = " The stepping."]
    pub stepping: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_cpu"][::std::mem::size_of::<pt_cpu>() - 8usize];
    ["Alignment of pt_cpu"][::std::mem::align_of::<pt_cpu>() - 4usize];
    ["Offset of field: pt_cpu::vendor"][::std::mem::offset_of!(pt_cpu, vendor) - 0usize];
    ["Offset of field: pt_cpu::family"][::std::mem::offset_of!(pt_cpu, family) - 4usize];
    ["Offset of field: pt_cpu::model"][::std::mem::offset_of!(pt_cpu, model) - 6usize];
    ["Offset of field: pt_cpu::stepping"][::std::mem::offset_of!(pt_cpu, stepping) - 7usize];
};
#[doc = " A collection of Intel PT errata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_errata {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub reserved: [u32; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_errata"][::std::mem::size_of::<pt_errata>() - 64usize];
    ["Alignment of pt_errata"][::std::mem::align_of::<pt_errata>() - 4usize];
    ["Offset of field: pt_errata::reserved"][::std::mem::offset_of!(pt_errata, reserved) - 4usize];
};
impl pt_errata {
    #[inline]
    pub fn bdm70(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bdm70(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bdm64(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bdm64(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skd007(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skd007(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skd022(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skd022(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skd010(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skd010(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skl014(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skl014(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apl12(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apl12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apl11(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apl11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skl168(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skl168(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skz84(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skz84(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bdm70: u32,
        bdm64: u32,
        skd007: u32,
        skd022: u32,
        skd010: u32,
        skl014: u32,
        apl12: u32,
        apl11: u32,
        skl168: u32,
        skz84: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bdm70: u32 = unsafe { ::std::mem::transmute(bdm70) };
            bdm70 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bdm64: u32 = unsafe { ::std::mem::transmute(bdm64) };
            bdm64 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skd007: u32 = unsafe { ::std::mem::transmute(skd007) };
            skd007 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let skd022: u32 = unsafe { ::std::mem::transmute(skd022) };
            skd022 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skd010: u32 = unsafe { ::std::mem::transmute(skd010) };
            skd010 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let skl014: u32 = unsafe { ::std::mem::transmute(skl014) };
            skl014 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let apl12: u32 = unsafe { ::std::mem::transmute(apl12) };
            apl12 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let apl11: u32 = unsafe { ::std::mem::transmute(apl11) };
            apl11 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let skl168: u32 = unsafe { ::std::mem::transmute(skl168) };
            skl168 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let skz84: u32 = unsafe { ::std::mem::transmute(skz84) };
            skz84 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A collection of decoder-specific configuration flags."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_conf_flags {
    pub variant: pt_conf_flags__bindgen_ty_1,
}
#[doc = " The decoder variant."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_conf_flags__bindgen_ty_1 {
    pub block: pt_conf_flags__bindgen_ty_1__bindgen_ty_1,
    pub insn: pt_conf_flags__bindgen_ty_1__bindgen_ty_2,
    pub query: pt_conf_flags__bindgen_ty_1__bindgen_ty_3,
    pub event: pt_conf_flags__bindgen_ty_1__bindgen_ty_4,
    pub reserved: [u32; 4usize],
}
#[doc = " Flags for the block decoder."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_flags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_flags__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of pt_conf_flags__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_1>() - 4usize];
};
impl pt_conf_flags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn end_on_call(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_end_on_call(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_tick_events(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_tick_events(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn end_on_jump(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_end_on_jump(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_tcal_on_ovf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_tcal_on_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_iflags_events(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_iflags_events(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        end_on_call: u32,
        enable_tick_events: u32,
        end_on_jump: u32,
        keep_tcal_on_ovf: u32,
        enable_iflags_events: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let end_on_call: u32 = unsafe { ::std::mem::transmute(end_on_call) };
            end_on_call as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_tick_events: u32 = unsafe { ::std::mem::transmute(enable_tick_events) };
            enable_tick_events as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let end_on_jump: u32 = unsafe { ::std::mem::transmute(end_on_jump) };
            end_on_jump as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let keep_tcal_on_ovf: u32 = unsafe { ::std::mem::transmute(keep_tcal_on_ovf) };
            keep_tcal_on_ovf as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enable_iflags_events: u32 = unsafe { ::std::mem::transmute(enable_iflags_events) };
            enable_iflags_events as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Flags for the instruction flow decoder."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_flags__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_flags__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Alignment of pt_conf_flags__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_2>() - 4usize];
};
impl pt_conf_flags__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn enable_tick_events(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_tick_events(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_tcal_on_ovf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_tcal_on_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_iflags_events(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_iflags_events(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_tick_events: u32,
        keep_tcal_on_ovf: u32,
        enable_iflags_events: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_tick_events: u32 = unsafe { ::std::mem::transmute(enable_tick_events) };
            enable_tick_events as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let keep_tcal_on_ovf: u32 = unsafe { ::std::mem::transmute(keep_tcal_on_ovf) };
            keep_tcal_on_ovf as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enable_iflags_events: u32 = unsafe { ::std::mem::transmute(enable_iflags_events) };
            enable_iflags_events as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Flags for the query decoder."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_flags__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_flags__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_3>() - 4usize];
    ["Alignment of pt_conf_flags__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_3>() - 4usize];
};
impl pt_conf_flags__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn keep_tcal_on_ovf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_tcal_on_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_iflags_events(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_iflags_events(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        keep_tcal_on_ovf: u32,
        enable_iflags_events: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let keep_tcal_on_ovf: u32 = unsafe { ::std::mem::transmute(keep_tcal_on_ovf) };
            keep_tcal_on_ovf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_iflags_events: u32 = unsafe { ::std::mem::transmute(enable_iflags_events) };
            enable_iflags_events as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Flags for the event decoder."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_flags__bindgen_ty_1__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_flags__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_4>() - 4usize];
    ["Alignment of pt_conf_flags__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<pt_conf_flags__bindgen_ty_1__bindgen_ty_4>() - 4usize];
};
impl pt_conf_flags__bindgen_ty_1__bindgen_ty_4 {
    #[inline]
    pub fn keep_tcal_on_ovf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_tcal_on_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_iflags_events(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_iflags_events(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        keep_tcal_on_ovf: u32,
        enable_iflags_events: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let keep_tcal_on_ovf: u32 = unsafe { ::std::mem::transmute(keep_tcal_on_ovf) };
            keep_tcal_on_ovf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_iflags_events: u32 = unsafe { ::std::mem::transmute(enable_iflags_events) };
            enable_iflags_events as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_flags__bindgen_ty_1"]
        [::std::mem::size_of::<pt_conf_flags__bindgen_ty_1>() - 16usize];
    ["Alignment of pt_conf_flags__bindgen_ty_1"]
        [::std::mem::align_of::<pt_conf_flags__bindgen_ty_1>() - 4usize];
    ["Offset of field: pt_conf_flags__bindgen_ty_1::block"]
        [::std::mem::offset_of!(pt_conf_flags__bindgen_ty_1, block) - 0usize];
    ["Offset of field: pt_conf_flags__bindgen_ty_1::insn"]
        [::std::mem::offset_of!(pt_conf_flags__bindgen_ty_1, insn) - 0usize];
    ["Offset of field: pt_conf_flags__bindgen_ty_1::query"]
        [::std::mem::offset_of!(pt_conf_flags__bindgen_ty_1, query) - 0usize];
    ["Offset of field: pt_conf_flags__bindgen_ty_1::event"]
        [::std::mem::offset_of!(pt_conf_flags__bindgen_ty_1, event) - 0usize];
    ["Offset of field: pt_conf_flags__bindgen_ty_1::reserved"]
        [::std::mem::offset_of!(pt_conf_flags__bindgen_ty_1, reserved) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_flags"][::std::mem::size_of::<pt_conf_flags>() - 16usize];
    ["Alignment of pt_conf_flags"][::std::mem::align_of::<pt_conf_flags>() - 4usize];
    ["Offset of field: pt_conf_flags::variant"]
        [::std::mem::offset_of!(pt_conf_flags, variant) - 0usize];
};
#[doc = " The address filter configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_conf_addr_filter {
    pub config: pt_conf_addr_filter__bindgen_ty_1,
    #[doc = " The address ranges configuration.\n\n This corresponds to the IA32_RTIT_ADDRn_A/B MSRs."]
    pub addr0_a: u64,
    pub addr0_b: u64,
    pub addr1_a: u64,
    pub addr1_b: u64,
    pub addr2_a: u64,
    pub addr2_b: u64,
    pub addr3_a: u64,
    pub addr3_b: u64,
    pub reserved: [u64; 8usize],
}
#[doc = " The address filter configuration.\n\n This corresponds to the respective fields in IA32_RTIT_CTL MSR."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_conf_addr_filter__bindgen_ty_1 {
    pub addr_cfg: u64,
    pub ctl: pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1>() - 4usize];
};
impl pt_conf_addr_filter__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn addr0_cfg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_addr0_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn addr1_cfg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_addr1_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn addr2_cfg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_addr2_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn addr3_cfg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_addr3_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr0_cfg: u32,
        addr1_cfg: u32,
        addr2_cfg: u32,
        addr3_cfg: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let addr0_cfg: u32 = unsafe { ::std::mem::transmute(addr0_cfg) };
            addr0_cfg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let addr1_cfg: u32 = unsafe { ::std::mem::transmute(addr1_cfg) };
            addr1_cfg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let addr2_cfg: u32 = unsafe { ::std::mem::transmute(addr2_cfg) };
            addr2_cfg as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let addr3_cfg: u32 = unsafe { ::std::mem::transmute(addr3_cfg) };
            addr3_cfg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_addr_filter__bindgen_ty_1"]
        [::std::mem::size_of::<pt_conf_addr_filter__bindgen_ty_1>() - 8usize];
    ["Alignment of pt_conf_addr_filter__bindgen_ty_1"]
        [::std::mem::align_of::<pt_conf_addr_filter__bindgen_ty_1>() - 8usize];
    ["Offset of field: pt_conf_addr_filter__bindgen_ty_1::addr_cfg"]
        [::std::mem::offset_of!(pt_conf_addr_filter__bindgen_ty_1, addr_cfg) - 0usize];
    ["Offset of field: pt_conf_addr_filter__bindgen_ty_1::ctl"]
        [::std::mem::offset_of!(pt_conf_addr_filter__bindgen_ty_1, ctl) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_conf_addr_filter"][::std::mem::size_of::<pt_conf_addr_filter>() - 136usize];
    ["Alignment of pt_conf_addr_filter"][::std::mem::align_of::<pt_conf_addr_filter>() - 8usize];
    ["Offset of field: pt_conf_addr_filter::config"]
        [::std::mem::offset_of!(pt_conf_addr_filter, config) - 0usize];
    ["Offset of field: pt_conf_addr_filter::addr0_a"]
        [::std::mem::offset_of!(pt_conf_addr_filter, addr0_a) - 8usize];
    ["Offset of field: pt_conf_addr_filter::addr0_b"]
        [::std::mem::offset_of!(pt_conf_addr_filter, addr0_b) - 16usize];
    ["Offset of field: pt_conf_addr_filter::addr1_a"]
        [::std::mem::offset_of!(pt_conf_addr_filter, addr1_a) - 24usize];
    ["Offset of field: pt_conf_addr_filter::addr1_b"]
        [::std::mem::offset_of!(pt_conf_addr_filter, addr1_b) - 32usize];
    ["Offset of field: pt_conf_addr_filter::addr2_a"]
        [::std::mem::offset_of!(pt_conf_addr_filter, addr2_a) - 40usize];
    ["Offset of field: pt_conf_addr_filter::addr2_b"]
        [::std::mem::offset_of!(pt_conf_addr_filter, addr2_b) - 48usize];
    ["Offset of field: pt_conf_addr_filter::addr3_a"]
        [::std::mem::offset_of!(pt_conf_addr_filter, addr3_a) - 56usize];
    ["Offset of field: pt_conf_addr_filter::addr3_b"]
        [::std::mem::offset_of!(pt_conf_addr_filter, addr3_b) - 64usize];
    ["Offset of field: pt_conf_addr_filter::reserved"]
        [::std::mem::offset_of!(pt_conf_addr_filter, reserved) - 72usize];
};
#[doc = " An Intel PT decoder configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_config {
    #[doc = " The size of the config structure in bytes."]
    pub size: usize,
    #[doc = " The trace buffer begin address."]
    pub begin: *mut u8,
    #[doc = " The trace buffer end address."]
    pub end: *mut u8,
    pub decode: pt_config__bindgen_ty_1,
    #[doc = " The cpu on which Intel PT has been recorded."]
    pub cpu: pt_cpu,
    #[doc = " The errata to apply when encoding or decoding Intel PT."]
    pub errata: pt_errata,
    pub cpuid_0x15_eax: u32,
    pub cpuid_0x15_ebx: u32,
    pub mtc_freq: u8,
    pub nom_freq: u8,
    #[doc = " A collection of decoder-specific flags."]
    pub flags: pt_conf_flags,
    #[doc = " The address filter configuration."]
    pub addr_filter: pt_conf_addr_filter,
}
#[doc = " An optional callback for handling unknown packets.\n\n If \\@callback is not NULL, it is called for any unknown opcode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_config__bindgen_ty_1 {
    #[doc = " The callback function.\n\n It shall decode the packet at \\@pos into \\@unknown.\n It shall return the number of bytes read upon success.\n It shall return a negative pt_error_code otherwise.\n The below context is passed as \\@context."]
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            unknown: *mut pt_packet_unknown,
            config: *const pt_config,
            pos: *const u8,
            context: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " The user-defined context for this configuration."]
    pub context: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_config__bindgen_ty_1"][::std::mem::size_of::<pt_config__bindgen_ty_1>() - 16usize];
    ["Alignment of pt_config__bindgen_ty_1"]
        [::std::mem::align_of::<pt_config__bindgen_ty_1>() - 8usize];
    ["Offset of field: pt_config__bindgen_ty_1::callback"]
        [::std::mem::offset_of!(pt_config__bindgen_ty_1, callback) - 0usize];
    ["Offset of field: pt_config__bindgen_ty_1::context"]
        [::std::mem::offset_of!(pt_config__bindgen_ty_1, context) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_config"][::std::mem::size_of::<pt_config>() - 280usize];
    ["Alignment of pt_config"][::std::mem::align_of::<pt_config>() - 8usize];
    ["Offset of field: pt_config::size"][::std::mem::offset_of!(pt_config, size) - 0usize];
    ["Offset of field: pt_config::begin"][::std::mem::offset_of!(pt_config, begin) - 8usize];
    ["Offset of field: pt_config::end"][::std::mem::offset_of!(pt_config, end) - 16usize];
    ["Offset of field: pt_config::decode"][::std::mem::offset_of!(pt_config, decode) - 24usize];
    ["Offset of field: pt_config::cpu"][::std::mem::offset_of!(pt_config, cpu) - 40usize];
    ["Offset of field: pt_config::errata"][::std::mem::offset_of!(pt_config, errata) - 48usize];
    ["Offset of field: pt_config::cpuid_0x15_eax"]
        [::std::mem::offset_of!(pt_config, cpuid_0x15_eax) - 112usize];
    ["Offset of field: pt_config::cpuid_0x15_ebx"]
        [::std::mem::offset_of!(pt_config, cpuid_0x15_ebx) - 116usize];
    ["Offset of field: pt_config::mtc_freq"]
        [::std::mem::offset_of!(pt_config, mtc_freq) - 120usize];
    ["Offset of field: pt_config::nom_freq"]
        [::std::mem::offset_of!(pt_config, nom_freq) - 121usize];
    ["Offset of field: pt_config::flags"][::std::mem::offset_of!(pt_config, flags) - 124usize];
    ["Offset of field: pt_config::addr_filter"]
        [::std::mem::offset_of!(pt_config, addr_filter) - 144usize];
};
extern "C" {
    #[doc = " Determine errata for a given cpu.\n\n Updates \\@errata based on \\@cpu.\n\n Returns 0 on success, a negative error code otherwise.\n Returns -pte_invalid if \\@errata or \\@cpu is NULL.\n Returns -pte_bad_cpu if \\@cpu is not known."]
    pub fn pt_cpu_errata(errata: *mut pt_errata, cpu: *const pt_cpu) -> ::std::os::raw::c_int;
}
pub const pt_packet_type_ppt_invalid: pt_packet_type = 0;
pub const pt_packet_type_ppt_unknown: pt_packet_type = 1;
pub const pt_packet_type_ppt_pad: pt_packet_type = 2;
pub const pt_packet_type_ppt_psb: pt_packet_type = 3;
pub const pt_packet_type_ppt_psbend: pt_packet_type = 4;
pub const pt_packet_type_ppt_fup: pt_packet_type = 5;
pub const pt_packet_type_ppt_tip: pt_packet_type = 6;
pub const pt_packet_type_ppt_tip_pge: pt_packet_type = 7;
pub const pt_packet_type_ppt_tip_pgd: pt_packet_type = 8;
pub const pt_packet_type_ppt_tnt_8: pt_packet_type = 9;
pub const pt_packet_type_ppt_tnt_64: pt_packet_type = 10;
pub const pt_packet_type_ppt_mode: pt_packet_type = 11;
pub const pt_packet_type_ppt_pip: pt_packet_type = 12;
pub const pt_packet_type_ppt_vmcs: pt_packet_type = 13;
pub const pt_packet_type_ppt_cbr: pt_packet_type = 14;
pub const pt_packet_type_ppt_tsc: pt_packet_type = 15;
pub const pt_packet_type_ppt_tma: pt_packet_type = 16;
pub const pt_packet_type_ppt_mtc: pt_packet_type = 17;
pub const pt_packet_type_ppt_cyc: pt_packet_type = 18;
pub const pt_packet_type_ppt_stop: pt_packet_type = 19;
pub const pt_packet_type_ppt_ovf: pt_packet_type = 20;
pub const pt_packet_type_ppt_mnt: pt_packet_type = 21;
pub const pt_packet_type_ppt_exstop: pt_packet_type = 22;
pub const pt_packet_type_ppt_mwait: pt_packet_type = 23;
pub const pt_packet_type_ppt_pwre: pt_packet_type = 24;
pub const pt_packet_type_ppt_pwrx: pt_packet_type = 25;
pub const pt_packet_type_ppt_ptw: pt_packet_type = 26;
pub const pt_packet_type_ppt_cfe: pt_packet_type = 27;
pub const pt_packet_type_ppt_evd: pt_packet_type = 28;
pub const pt_packet_type_ppt_trig: pt_packet_type = 29;
#[doc = " Intel PT packet types."]
pub type pt_packet_type = i32;
pub const pt_ip_compression_pt_ipc_suppressed: pt_ip_compression = 0;
pub const pt_ip_compression_pt_ipc_update_16: pt_ip_compression = 1;
pub const pt_ip_compression_pt_ipc_update_32: pt_ip_compression = 2;
pub const pt_ip_compression_pt_ipc_sext_48: pt_ip_compression = 3;
pub const pt_ip_compression_pt_ipc_update_48: pt_ip_compression = 4;
pub const pt_ip_compression_pt_ipc_full: pt_ip_compression = 6;
#[doc = " The IP compression."]
pub type pt_ip_compression = i32;
pub const pt_exec_mode_ptem_unknown: pt_exec_mode = 0;
pub const pt_exec_mode_ptem_16bit: pt_exec_mode = 1;
pub const pt_exec_mode_ptem_32bit: pt_exec_mode = 2;
pub const pt_exec_mode_ptem_64bit: pt_exec_mode = 3;
#[doc = " An execution mode."]
pub type pt_exec_mode = i32;
pub const pt_mode_leaf_pt_mol_exec: pt_mode_leaf = 0;
pub const pt_mode_leaf_pt_mol_tsx: pt_mode_leaf = 32;
#[doc = " Mode packet leaves."]
pub type pt_mode_leaf = i32;
#[doc = " A TNT-8 or TNT-64 packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_tnt {
    #[doc = " TNT payload bit size."]
    pub bit_size: u8,
    #[doc = " TNT payload excluding stop bit."]
    pub payload: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_tnt"][::std::mem::size_of::<pt_packet_tnt>() - 16usize];
    ["Alignment of pt_packet_tnt"][::std::mem::align_of::<pt_packet_tnt>() - 8usize];
    ["Offset of field: pt_packet_tnt::bit_size"]
        [::std::mem::offset_of!(pt_packet_tnt, bit_size) - 0usize];
    ["Offset of field: pt_packet_tnt::payload"]
        [::std::mem::offset_of!(pt_packet_tnt, payload) - 8usize];
};
#[doc = " A packet with IP payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_ip {
    #[doc = " IP compression."]
    pub ipc: pt_ip_compression,
    #[doc = " Zero-extended payload ip."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_ip"][::std::mem::size_of::<pt_packet_ip>() - 16usize];
    ["Alignment of pt_packet_ip"][::std::mem::align_of::<pt_packet_ip>() - 8usize];
    ["Offset of field: pt_packet_ip::ipc"][::std::mem::offset_of!(pt_packet_ip, ipc) - 0usize];
    ["Offset of field: pt_packet_ip::ip"][::std::mem::offset_of!(pt_packet_ip, ip) - 8usize];
};
#[doc = " A mode.exec packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mode_exec {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_mode_exec"][::std::mem::size_of::<pt_packet_mode_exec>() - 4usize];
    ["Alignment of pt_packet_mode_exec"][::std::mem::align_of::<pt_packet_mode_exec>() - 4usize];
};
impl pt_packet_mode_exec {
    #[inline]
    pub fn csl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_csd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn iflag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iflag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(csl: u32, csd: u32, iflag: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let csl: u32 = unsafe { ::std::mem::transmute(csl) };
            csl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csd: u32 = unsafe { ::std::mem::transmute(csd) };
            csd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let iflag: u32 = unsafe { ::std::mem::transmute(iflag) };
            iflag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A mode.tsx packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mode_tsx {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_mode_tsx"][::std::mem::size_of::<pt_packet_mode_tsx>() - 4usize];
    ["Alignment of pt_packet_mode_tsx"][::std::mem::align_of::<pt_packet_mode_tsx>() - 4usize];
};
impl pt_packet_mode_tsx {
    #[inline]
    pub fn intx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn abrt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_abrt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intx: u32, abrt: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let intx: u32 = unsafe { ::std::mem::transmute(intx) };
            intx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let abrt: u32 = unsafe { ::std::mem::transmute(abrt) };
            abrt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A mode packet."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_packet_mode {
    #[doc = " Mode leaf."]
    pub leaf: pt_mode_leaf,
    pub bits: pt_packet_mode__bindgen_ty_1,
}
#[doc = " Mode bits."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_packet_mode__bindgen_ty_1 {
    #[doc = " Packet: mode.exec."]
    pub exec: pt_packet_mode_exec,
    #[doc = " Packet: mode.tsx."]
    pub tsx: pt_packet_mode_tsx,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_mode__bindgen_ty_1"]
        [::std::mem::size_of::<pt_packet_mode__bindgen_ty_1>() - 4usize];
    ["Alignment of pt_packet_mode__bindgen_ty_1"]
        [::std::mem::align_of::<pt_packet_mode__bindgen_ty_1>() - 4usize];
    ["Offset of field: pt_packet_mode__bindgen_ty_1::exec"]
        [::std::mem::offset_of!(pt_packet_mode__bindgen_ty_1, exec) - 0usize];
    ["Offset of field: pt_packet_mode__bindgen_ty_1::tsx"]
        [::std::mem::offset_of!(pt_packet_mode__bindgen_ty_1, tsx) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_mode"][::std::mem::size_of::<pt_packet_mode>() - 8usize];
    ["Alignment of pt_packet_mode"][::std::mem::align_of::<pt_packet_mode>() - 4usize];
    ["Offset of field: pt_packet_mode::leaf"]
        [::std::mem::offset_of!(pt_packet_mode, leaf) - 0usize];
    ["Offset of field: pt_packet_mode::bits"]
        [::std::mem::offset_of!(pt_packet_mode, bits) - 4usize];
};
#[doc = " A PIP packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_pip {
    #[doc = " The CR3 value."]
    pub cr3: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_pip"][::std::mem::size_of::<pt_packet_pip>() - 16usize];
    ["Alignment of pt_packet_pip"][::std::mem::align_of::<pt_packet_pip>() - 8usize];
    ["Offset of field: pt_packet_pip::cr3"][::std::mem::offset_of!(pt_packet_pip, cr3) - 0usize];
};
impl pt_packet_pip {
    #[inline]
    pub fn nr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(nr: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nr: u32 = unsafe { ::std::mem::transmute(nr) };
            nr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A TSC packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_tsc {
    #[doc = " The TSC value."]
    pub tsc: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_tsc"][::std::mem::size_of::<pt_packet_tsc>() - 8usize];
    ["Alignment of pt_packet_tsc"][::std::mem::align_of::<pt_packet_tsc>() - 8usize];
    ["Offset of field: pt_packet_tsc::tsc"][::std::mem::offset_of!(pt_packet_tsc, tsc) - 0usize];
};
#[doc = " A CBR packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_cbr {
    #[doc = " The core/bus cycle ratio."]
    pub ratio: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_cbr"][::std::mem::size_of::<pt_packet_cbr>() - 1usize];
    ["Alignment of pt_packet_cbr"][::std::mem::align_of::<pt_packet_cbr>() - 1usize];
    ["Offset of field: pt_packet_cbr::ratio"]
        [::std::mem::offset_of!(pt_packet_cbr, ratio) - 0usize];
};
#[doc = " A TMA packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_tma {
    #[doc = " The crystal clock tick counter value."]
    pub ctc: u16,
    #[doc = " The fast counter value."]
    pub fc: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_tma"][::std::mem::size_of::<pt_packet_tma>() - 4usize];
    ["Alignment of pt_packet_tma"][::std::mem::align_of::<pt_packet_tma>() - 2usize];
    ["Offset of field: pt_packet_tma::ctc"][::std::mem::offset_of!(pt_packet_tma, ctc) - 0usize];
    ["Offset of field: pt_packet_tma::fc"][::std::mem::offset_of!(pt_packet_tma, fc) - 2usize];
};
#[doc = " A MTC packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mtc {
    #[doc = " The crystal clock tick counter value."]
    pub ctc: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_mtc"][::std::mem::size_of::<pt_packet_mtc>() - 1usize];
    ["Alignment of pt_packet_mtc"][::std::mem::align_of::<pt_packet_mtc>() - 1usize];
    ["Offset of field: pt_packet_mtc::ctc"][::std::mem::offset_of!(pt_packet_mtc, ctc) - 0usize];
};
#[doc = " A CYC packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_cyc {
    #[doc = " The cycle counter value."]
    pub value: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_cyc"][::std::mem::size_of::<pt_packet_cyc>() - 8usize];
    ["Alignment of pt_packet_cyc"][::std::mem::align_of::<pt_packet_cyc>() - 8usize];
    ["Offset of field: pt_packet_cyc::value"]
        [::std::mem::offset_of!(pt_packet_cyc, value) - 0usize];
};
#[doc = " A VMCS packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_vmcs {
    pub base: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_vmcs"][::std::mem::size_of::<pt_packet_vmcs>() - 8usize];
    ["Alignment of pt_packet_vmcs"][::std::mem::align_of::<pt_packet_vmcs>() - 8usize];
    ["Offset of field: pt_packet_vmcs::base"]
        [::std::mem::offset_of!(pt_packet_vmcs, base) - 0usize];
};
#[doc = " A MNT packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mnt {
    #[doc = " The raw payload."]
    pub payload: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_mnt"][::std::mem::size_of::<pt_packet_mnt>() - 8usize];
    ["Alignment of pt_packet_mnt"][::std::mem::align_of::<pt_packet_mnt>() - 8usize];
    ["Offset of field: pt_packet_mnt::payload"]
        [::std::mem::offset_of!(pt_packet_mnt, payload) - 0usize];
};
#[doc = " A EXSTOP packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_exstop {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_exstop"][::std::mem::size_of::<pt_packet_exstop>() - 4usize];
    ["Alignment of pt_packet_exstop"][::std::mem::align_of::<pt_packet_exstop>() - 4usize];
};
impl pt_packet_exstop {
    #[inline]
    pub fn ip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip: u32 = unsafe { ::std::mem::transmute(ip) };
            ip as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A MWAIT packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_mwait {
    #[doc = " The MWAIT hints (EAX)."]
    pub hints: u32,
    #[doc = " The MWAIT extensions (ECX)."]
    pub ext: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_mwait"][::std::mem::size_of::<pt_packet_mwait>() - 8usize];
    ["Alignment of pt_packet_mwait"][::std::mem::align_of::<pt_packet_mwait>() - 4usize];
    ["Offset of field: pt_packet_mwait::hints"]
        [::std::mem::offset_of!(pt_packet_mwait, hints) - 0usize];
    ["Offset of field: pt_packet_mwait::ext"]
        [::std::mem::offset_of!(pt_packet_mwait, ext) - 4usize];
};
#[doc = " A PWRE packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_pwre {
    #[doc = " The resolved thread C-state."]
    pub state: u8,
    #[doc = " The resolved thread sub C-state."]
    pub sub_state: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_pwre"][::std::mem::size_of::<pt_packet_pwre>() - 4usize];
    ["Alignment of pt_packet_pwre"][::std::mem::align_of::<pt_packet_pwre>() - 4usize];
    ["Offset of field: pt_packet_pwre::state"]
        [::std::mem::offset_of!(pt_packet_pwre, state) - 0usize];
    ["Offset of field: pt_packet_pwre::sub_state"]
        [::std::mem::offset_of!(pt_packet_pwre, sub_state) - 1usize];
};
impl pt_packet_pwre {
    #[inline]
    pub fn hw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hw: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw: u32 = unsafe { ::std::mem::transmute(hw) };
            hw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A PWRX packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_pwrx {
    #[doc = " The core C-state at the time of the wake."]
    pub last: u8,
    #[doc = " The deepest core C-state achieved during sleep."]
    pub deepest: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_pwrx"][::std::mem::size_of::<pt_packet_pwrx>() - 4usize];
    ["Alignment of pt_packet_pwrx"][::std::mem::align_of::<pt_packet_pwrx>() - 4usize];
    ["Offset of field: pt_packet_pwrx::last"]
        [::std::mem::offset_of!(pt_packet_pwrx, last) - 0usize];
    ["Offset of field: pt_packet_pwrx::deepest"]
        [::std::mem::offset_of!(pt_packet_pwrx, deepest) - 1usize];
};
impl pt_packet_pwrx {
    #[inline]
    pub fn interrupt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interrupt: u32,
        store: u32,
        autonomous: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt: u32 = unsafe { ::std::mem::transmute(interrupt) };
            interrupt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let store: u32 = unsafe { ::std::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A PTW packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_ptw {
    #[doc = " The raw payload."]
    pub payload: u64,
    #[doc = " The payload size as encoded in the packet."]
    pub plc: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_ptw"][::std::mem::size_of::<pt_packet_ptw>() - 16usize];
    ["Alignment of pt_packet_ptw"][::std::mem::align_of::<pt_packet_ptw>() - 8usize];
    ["Offset of field: pt_packet_ptw::payload"]
        [::std::mem::offset_of!(pt_packet_ptw, payload) - 0usize];
    ["Offset of field: pt_packet_ptw::plc"][::std::mem::offset_of!(pt_packet_ptw, plc) - 8usize];
};
impl pt_packet_ptw {
    #[inline]
    pub fn ip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip: u32 = unsafe { ::std::mem::transmute(ip) };
            ip as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const pt_cfe_type_pt_cfe_intr: pt_cfe_type = 1;
pub const pt_cfe_type_pt_cfe_iret: pt_cfe_type = 2;
pub const pt_cfe_type_pt_cfe_smi: pt_cfe_type = 3;
pub const pt_cfe_type_pt_cfe_rsm: pt_cfe_type = 4;
pub const pt_cfe_type_pt_cfe_sipi: pt_cfe_type = 5;
pub const pt_cfe_type_pt_cfe_init: pt_cfe_type = 6;
pub const pt_cfe_type_pt_cfe_vmentry: pt_cfe_type = 7;
pub const pt_cfe_type_pt_cfe_vmexit: pt_cfe_type = 8;
pub const pt_cfe_type_pt_cfe_vmexit_intr: pt_cfe_type = 9;
pub const pt_cfe_type_pt_cfe_shutdown: pt_cfe_type = 10;
pub const pt_cfe_type_pt_cfe_uintr: pt_cfe_type = 12;
pub const pt_cfe_type_pt_cfe_uiret: pt_cfe_type = 13;
pub type pt_cfe_type = i32;
pub const pt_cfe_intr_pt_cfe_intr_de: pt_cfe_intr = 0;
pub const pt_cfe_intr_pt_cfe_intr_db: pt_cfe_intr = 1;
pub const pt_cfe_intr_pt_cfe_intr_nmi: pt_cfe_intr = 2;
pub const pt_cfe_intr_pt_cfe_intr_bp: pt_cfe_intr = 3;
pub const pt_cfe_intr_pt_cfe_intr_of: pt_cfe_intr = 4;
pub const pt_cfe_intr_pt_cfe_intr_br: pt_cfe_intr = 5;
pub const pt_cfe_intr_pt_cfe_intr_ud: pt_cfe_intr = 6;
pub const pt_cfe_intr_pt_cfe_intr_nm: pt_cfe_intr = 7;
pub const pt_cfe_intr_pt_cfe_intr_df: pt_cfe_intr = 8;
pub const pt_cfe_intr_pt_cfe_intr_ts: pt_cfe_intr = 10;
pub const pt_cfe_intr_pt_cfe_intr_np: pt_cfe_intr = 11;
pub const pt_cfe_intr_pt_cfe_intr_ss: pt_cfe_intr = 12;
pub const pt_cfe_intr_pt_cfe_intr_gp: pt_cfe_intr = 13;
pub const pt_cfe_intr_pt_cfe_intr_pf: pt_cfe_intr = 14;
pub const pt_cfe_intr_pt_cfe_intr_mf: pt_cfe_intr = 16;
pub const pt_cfe_intr_pt_cfe_intr_ac: pt_cfe_intr = 17;
pub const pt_cfe_intr_pt_cfe_intr_mc: pt_cfe_intr = 18;
pub const pt_cfe_intr_pt_cfe_intr_xm: pt_cfe_intr = 19;
pub const pt_cfe_intr_pt_cfe_intr_ve: pt_cfe_intr = 20;
pub const pt_cfe_intr_pt_cfe_intr_cp: pt_cfe_intr = 21;
pub type pt_cfe_intr = i32;
#[doc = " A CFE packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_cfe {
    #[doc = " The type of control-flow event."]
    pub type_: pt_cfe_type,
    #[doc = " The vector depending on the type:\n\n  pt_cfe_intr:\tthe event vector.\n  pt_cfe_vmexit_intr:\tthe event vector.\n  pt_cfe_sipi:\tthe SIPI vector.\n  pt_cfe_uintr:\tthe user interrupt vector."]
    pub vector: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_cfe"][::std::mem::size_of::<pt_packet_cfe>() - 8usize];
    ["Alignment of pt_packet_cfe"][::std::mem::align_of::<pt_packet_cfe>() - 4usize];
    ["Offset of field: pt_packet_cfe::type_"]
        [::std::mem::offset_of!(pt_packet_cfe, type_) - 0usize];
    ["Offset of field: pt_packet_cfe::vector"]
        [::std::mem::offset_of!(pt_packet_cfe, vector) - 4usize];
};
impl pt_packet_cfe {
    #[inline]
    pub fn ip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip: u32 = unsafe { ::std::mem::transmute(ip) };
            ip as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const pt_evd_type_pt_evd_cr2: pt_evd_type = 0;
pub const pt_evd_type_pt_evd_vmxq: pt_evd_type = 1;
pub const pt_evd_type_pt_evd_vmxr: pt_evd_type = 2;
pub type pt_evd_type = i32;
#[doc = " A EVD packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_evd {
    #[doc = " The type of control-flow event."]
    pub type_: pt_evd_type,
    #[doc = " The payload depending on the type:\n\n  0x00: page fault linear address (cr2).\n  0x01: vmx exit qualification.\n  0x02: vmx exit reason."]
    pub payload: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_evd"][::std::mem::size_of::<pt_packet_evd>() - 16usize];
    ["Alignment of pt_packet_evd"][::std::mem::align_of::<pt_packet_evd>() - 8usize];
    ["Offset of field: pt_packet_evd::type_"]
        [::std::mem::offset_of!(pt_packet_evd, type_) - 0usize];
    ["Offset of field: pt_packet_evd::payload"]
        [::std::mem::offset_of!(pt_packet_evd, payload) - 8usize];
};
#[doc = " A TRIG packet."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_trig {
    #[doc = " A bit vector of triggers that are represented by this packet."]
    pub trbv: u8,
    #[doc = " An instruction count from the last IP packet (FUP, TIP*, or TNT)\n indicating the instruction to which this packet is attributed.\n\n This field is only valid if \\@icntv is set."]
    pub icnt: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_trig"][::std::mem::size_of::<pt_packet_trig>() - 8usize];
    ["Alignment of pt_packet_trig"][::std::mem::align_of::<pt_packet_trig>() - 4usize];
    ["Offset of field: pt_packet_trig::trbv"]
        [::std::mem::offset_of!(pt_packet_trig, trbv) - 0usize];
    ["Offset of field: pt_packet_trig::icnt"]
        [::std::mem::offset_of!(pt_packet_trig, icnt) - 2usize];
};
impl pt_packet_trig {
    #[inline]
    pub fn ip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icntv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icntv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mult(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mult(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip: u32, icntv: u32, mult: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip: u32 = unsafe { ::std::mem::transmute(ip) };
            ip as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let icntv: u32 = unsafe { ::std::mem::transmute(icntv) };
            icntv as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mult: u32 = unsafe { ::std::mem::transmute(mult) };
            mult as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " An unknown packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_packet_unknown {
    #[doc = " Pointer to the raw packet bytes."]
    pub packet: *const u8,
    #[doc = " Optional pointer to a user-defined structure."]
    pub priv_: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet_unknown"][::std::mem::size_of::<pt_packet_unknown>() - 16usize];
    ["Alignment of pt_packet_unknown"][::std::mem::align_of::<pt_packet_unknown>() - 8usize];
    ["Offset of field: pt_packet_unknown::packet"]
        [::std::mem::offset_of!(pt_packet_unknown, packet) - 0usize];
    ["Offset of field: pt_packet_unknown::priv_"]
        [::std::mem::offset_of!(pt_packet_unknown, priv_) - 8usize];
};
#[doc = " An Intel PT packet."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_packet {
    #[doc = " The type of the packet.\n\n This also determines the \\@payload field."]
    pub type_: pt_packet_type,
    #[doc = " The size of the packet including opcode and payload."]
    pub size: u8,
    pub payload: pt_packet__bindgen_ty_1,
}
#[doc = " Packet specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_packet__bindgen_ty_1 {
    #[doc = " Packet: tnt-8, tnt-64."]
    pub tnt: pt_packet_tnt,
    #[doc = " Packet: tip, fup, tip.pge, tip.pgd."]
    pub ip: pt_packet_ip,
    #[doc = " Packet: mode."]
    pub mode: pt_packet_mode,
    #[doc = " Packet: pip."]
    pub pip: pt_packet_pip,
    #[doc = " Packet: tsc."]
    pub tsc: pt_packet_tsc,
    #[doc = " Packet: cbr."]
    pub cbr: pt_packet_cbr,
    #[doc = " Packet: tma."]
    pub tma: pt_packet_tma,
    #[doc = " Packet: mtc."]
    pub mtc: pt_packet_mtc,
    #[doc = " Packet: cyc."]
    pub cyc: pt_packet_cyc,
    #[doc = " Packet: vmcs."]
    pub vmcs: pt_packet_vmcs,
    #[doc = " Packet: mnt."]
    pub mnt: pt_packet_mnt,
    #[doc = " Packet: exstop."]
    pub exstop: pt_packet_exstop,
    #[doc = " Packet: mwait."]
    pub mwait: pt_packet_mwait,
    #[doc = " Packet: pwre."]
    pub pwre: pt_packet_pwre,
    #[doc = " Packet: pwrx."]
    pub pwrx: pt_packet_pwrx,
    #[doc = " Packet: ptw."]
    pub ptw: pt_packet_ptw,
    #[doc = " Packet: cfe."]
    pub cfe: pt_packet_cfe,
    #[doc = " Packet: evd."]
    pub evd: pt_packet_evd,
    #[doc = " Packet: trig."]
    pub trig: pt_packet_trig,
    #[doc = " Packet: unknown."]
    pub unknown: pt_packet_unknown,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet__bindgen_ty_1"][::std::mem::size_of::<pt_packet__bindgen_ty_1>() - 16usize];
    ["Alignment of pt_packet__bindgen_ty_1"]
        [::std::mem::align_of::<pt_packet__bindgen_ty_1>() - 8usize];
    ["Offset of field: pt_packet__bindgen_ty_1::tnt"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, tnt) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::ip"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, ip) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::mode"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, mode) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::pip"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, pip) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::tsc"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, tsc) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::cbr"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, cbr) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::tma"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, tma) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::mtc"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, mtc) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::cyc"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, cyc) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::vmcs"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, vmcs) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::mnt"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, mnt) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::exstop"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, exstop) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::mwait"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, mwait) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::pwre"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, pwre) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::pwrx"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, pwrx) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::ptw"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, ptw) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::cfe"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, cfe) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::evd"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, evd) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::trig"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, trig) - 0usize];
    ["Offset of field: pt_packet__bindgen_ty_1::unknown"]
        [::std::mem::offset_of!(pt_packet__bindgen_ty_1, unknown) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_packet"][::std::mem::size_of::<pt_packet>() - 24usize];
    ["Alignment of pt_packet"][::std::mem::align_of::<pt_packet>() - 8usize];
    ["Offset of field: pt_packet::type_"][::std::mem::offset_of!(pt_packet, type_) - 0usize];
    ["Offset of field: pt_packet::size"][::std::mem::offset_of!(pt_packet, size) - 4usize];
    ["Offset of field: pt_packet::payload"][::std::mem::offset_of!(pt_packet, payload) - 8usize];
};
extern "C" {
    #[doc = " Allocate an Intel PT packet encoder.\n\n The encoder will work on the buffer defined in \\@config, it shall contain\n raw trace data and remain valid for the lifetime of the encoder.\n\n The encoder starts at the beginning of the trace buffer."]
    pub fn pt_alloc_encoder(config: *const pt_config) -> *mut pt_encoder;
}
extern "C" {
    #[doc = " Free an Intel PT packet encoder.\n\n The \\@encoder must not be used after a successful return."]
    pub fn pt_free_encoder(encoder: *mut pt_encoder);
}
extern "C" {
    #[doc = " Hard set synchronization point of an Intel PT packet encoder.\n\n Synchronize \\@encoder to \\@offset within the trace buffer.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_eos if the given offset is behind the end of the trace buffer.\n Returns -pte_invalid if \\@encoder is NULL."]
    pub fn pt_enc_sync_set(encoder: *mut pt_encoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current packet encoder position.\n\n Fills the current \\@encoder position into \\@offset.\n\n This is useful for reporting errors.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@encoder or \\@offset is NULL."]
    pub fn pt_enc_get_offset(encoder: *const pt_encoder, offset: *mut u64)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_enc_get_config(encoder: *const pt_encoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Encode an Intel PT packet.\n\n Writes \\@packet at \\@encoder's current position in the Intel PT buffer and\n advances the \\@encoder beyond the written packet.\n\n The \\@packet.size field is ignored.\n\n In case of errors, the \\@encoder is not advanced and nothing is written\n into the Intel PT buffer.\n\n Returns the number of bytes written on success, a negative error code\n otherwise.\n\n Returns -pte_bad_opc if \\@packet.type is not known.\n Returns -pte_bad_packet if \\@packet's payload is invalid.\n Returns -pte_eos if \\@encoder reached the end of the Intel PT buffer.\n Returns -pte_invalid if \\@encoder or \\@packet is NULL."]
    pub fn pt_enc_next(encoder: *mut pt_encoder, packet: *const pt_packet)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an Intel PT packet decoder.\n\n The decoder will work on the buffer defined in \\@config, it shall contain\n raw trace data and remain valid for the lifetime of the decoder.\n\n The decoder needs to be synchronized before it can be used."]
    pub fn pt_pkt_alloc_decoder(config: *const pt_config) -> *mut pt_packet_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT packet decoder.\n\n The \\@decoder must not be used after a successful return."]
    pub fn pt_pkt_free_decoder(decoder: *mut pt_packet_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT packet decoder.\n\n Search for the next synchronization point in forward or backward direction.\n\n If \\@decoder has not been synchronized, yet, the search is started at the\n beginning of the trace buffer in case of forward synchronization and at the\n end of the trace buffer in case of backward synchronization.\n\n Returns zero or a positive value on success, a negative error code otherwise.\n\n Returns -pte_eos if no further synchronization point is found.\n Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_pkt_sync_forward(decoder: *mut pt_packet_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_pkt_sync_backward(decoder: *mut pt_packet_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hard set synchronization point of an Intel PT decoder.\n\n Synchronize \\@decoder to \\@offset within the trace buffer.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_eos if the given offset is behind the end of the trace buffer.\n Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_pkt_sync_set(decoder: *mut pt_packet_decoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position.\n\n Fills the current \\@decoder position into \\@offset.\n\n This is useful for reporting errors.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_pkt_get_offset(
        decoder: *const pt_packet_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point.\n\n Fills the last synchronization position into \\@offset.\n\n This is useful when splitting a trace stream for parallel decoding.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_pkt_get_sync_offset(
        decoder: *const pt_packet_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_pkt_get_config(decoder: *const pt_packet_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Decode the next packet and advance the decoder.\n\n Decodes the packet at \\@decoder's current position into \\@packet and\n adjusts the \\@decoder's position by the number of bytes the packet had\n consumed.\n\n The \\@size argument must be set to sizeof(struct pt_packet).\n\n Returns the number of bytes consumed on success, a negative error code\n otherwise.\n\n Returns -pte_bad_opc if the packet is unknown.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if \\@decoder reached the end of the Intel PT buffer.\n Returns -pte_invalid if \\@decoder or \\@packet is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_pkt_next(
        decoder: *mut pt_packet_decoder,
        packet: *mut pt_packet,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
pub const pt_event_type_ptev_enabled: pt_event_type = 0;
pub const pt_event_type_ptev_disabled: pt_event_type = 1;
pub const pt_event_type_ptev_async_disabled: pt_event_type = 2;
pub const pt_event_type_ptev_async_branch: pt_event_type = 3;
pub const pt_event_type_ptev_paging: pt_event_type = 4;
pub const pt_event_type_ptev_async_paging: pt_event_type = 5;
pub const pt_event_type_ptev_overflow: pt_event_type = 6;
pub const pt_event_type_ptev_exec_mode: pt_event_type = 7;
pub const pt_event_type_ptev_tsx: pt_event_type = 8;
pub const pt_event_type_ptev_stop: pt_event_type = 9;
pub const pt_event_type_ptev_vmcs: pt_event_type = 10;
pub const pt_event_type_ptev_async_vmcs: pt_event_type = 11;
pub const pt_event_type_ptev_exstop: pt_event_type = 12;
pub const pt_event_type_ptev_mwait: pt_event_type = 13;
pub const pt_event_type_ptev_pwre: pt_event_type = 14;
pub const pt_event_type_ptev_pwrx: pt_event_type = 15;
pub const pt_event_type_ptev_ptwrite: pt_event_type = 16;
pub const pt_event_type_ptev_tick: pt_event_type = 17;
pub const pt_event_type_ptev_cbr: pt_event_type = 18;
pub const pt_event_type_ptev_mnt: pt_event_type = 19;
pub const pt_event_type_ptev_tip: pt_event_type = 20;
pub const pt_event_type_ptev_tnt: pt_event_type = 21;
pub const pt_event_type_ptev_iflags: pt_event_type = 22;
pub const pt_event_type_ptev_interrupt: pt_event_type = 23;
pub const pt_event_type_ptev_iret: pt_event_type = 24;
pub const pt_event_type_ptev_smi: pt_event_type = 25;
pub const pt_event_type_ptev_rsm: pt_event_type = 26;
pub const pt_event_type_ptev_sipi: pt_event_type = 27;
pub const pt_event_type_ptev_init: pt_event_type = 28;
pub const pt_event_type_ptev_vmentry: pt_event_type = 29;
pub const pt_event_type_ptev_vmexit: pt_event_type = 30;
pub const pt_event_type_ptev_shutdown: pt_event_type = 31;
pub const pt_event_type_ptev_uintr: pt_event_type = 32;
pub const pt_event_type_ptev_uiret: pt_event_type = 33;
pub const pt_event_type_ptev_trig: pt_event_type = 34;
#[doc = " Event types."]
pub type pt_event_type = i32;
#[doc = " An event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_event {
    #[doc = " The type of the event."]
    pub type_: pt_event_type,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The time stamp count of the event.\n\n This field is only valid if \\@has_tsc is set."]
    pub tsc: u64,
    #[doc = " The number of lost mtc and cyc packets.\n\n This gives an idea about the quality of the \\@tsc.  The more packets\n were dropped, the less precise timing is."]
    pub lost_mtc: u32,
    pub lost_cyc: u32,
    pub reserved: [u64; 2usize],
    pub variant: pt_event__bindgen_ty_1,
}
#[doc = " Event specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pt_event__bindgen_ty_1 {
    pub enabled: pt_event__bindgen_ty_1__bindgen_ty_1,
    pub disabled: pt_event__bindgen_ty_1__bindgen_ty_2,
    pub async_disabled: pt_event__bindgen_ty_1__bindgen_ty_3,
    pub async_branch: pt_event__bindgen_ty_1__bindgen_ty_4,
    pub paging: pt_event__bindgen_ty_1__bindgen_ty_5,
    pub async_paging: pt_event__bindgen_ty_1__bindgen_ty_6,
    pub overflow: pt_event__bindgen_ty_1__bindgen_ty_7,
    pub exec_mode: pt_event__bindgen_ty_1__bindgen_ty_8,
    pub tsx: pt_event__bindgen_ty_1__bindgen_ty_9,
    pub vmcs: pt_event__bindgen_ty_1__bindgen_ty_10,
    pub async_vmcs: pt_event__bindgen_ty_1__bindgen_ty_11,
    pub exstop: pt_event__bindgen_ty_1__bindgen_ty_12,
    pub mwait: pt_event__bindgen_ty_1__bindgen_ty_13,
    pub pwre: pt_event__bindgen_ty_1__bindgen_ty_14,
    pub pwrx: pt_event__bindgen_ty_1__bindgen_ty_15,
    pub ptwrite: pt_event__bindgen_ty_1__bindgen_ty_16,
    pub tick: pt_event__bindgen_ty_1__bindgen_ty_17,
    pub cbr: pt_event__bindgen_ty_1__bindgen_ty_18,
    pub mnt: pt_event__bindgen_ty_1__bindgen_ty_19,
    pub tip: pt_event__bindgen_ty_1__bindgen_ty_20,
    pub tnt: pt_event__bindgen_ty_1__bindgen_ty_21,
    pub iflags: pt_event__bindgen_ty_1__bindgen_ty_22,
    pub interrupt: pt_event__bindgen_ty_1__bindgen_ty_23,
    pub iret: pt_event__bindgen_ty_1__bindgen_ty_24,
    pub smi: pt_event__bindgen_ty_1__bindgen_ty_25,
    pub rsm: pt_event__bindgen_ty_1__bindgen_ty_26,
    pub sipi: pt_event__bindgen_ty_1__bindgen_ty_27,
    pub init: pt_event__bindgen_ty_1__bindgen_ty_28,
    pub vmentry: pt_event__bindgen_ty_1__bindgen_ty_29,
    pub vmexit: pt_event__bindgen_ty_1__bindgen_ty_30,
    pub shutdown: pt_event__bindgen_ty_1__bindgen_ty_31,
    pub uintr: pt_event__bindgen_ty_1__bindgen_ty_32,
    pub uiret: pt_event__bindgen_ty_1__bindgen_ty_33,
    pub trig: pt_event__bindgen_ty_1__bindgen_ty_34,
}
#[doc = " Event: enabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The address at which tracing resumes."]
    pub ip: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_1::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_1, ip) - 0usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn resumed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resumed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(resumed: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resumed: u32 = unsafe { ::std::mem::transmute(resumed) };
            resumed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: disabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The destination of the first branch inside a\n filtered area.\n\n This field is not valid if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_2::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_2, ip) - 0usize];
};
#[doc = " Event: async disabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " The source address of the asynchronous branch that\n disabled tracing."]
    pub at: u64,
    #[doc = " The destination of the first branch inside a\n filtered area.\n\n This field is not valid if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_3::at"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_3, at) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_3::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_3, ip) - 8usize];
};
#[doc = " Event: async branch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " The branch source address."]
    pub from: u64,
    #[doc = " The branch destination address.\n\n This field is not valid if \\@ip_suppressed is set."]
    pub to: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_4>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_4::from"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_4, from) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_4::to"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_4, to) - 8usize];
};
#[doc = " Event: paging."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_5 {
    #[doc = " The updated CR3 value.\n\n The lower 5 bit have been zeroed out.\n The upper bits have been zeroed out depending on the\n maximum possible address."]
    pub cr3: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_5>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_5::cr3"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_5, cr3) - 0usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_5 {
    #[inline]
    pub fn non_root(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_root(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(non_root: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let non_root: u32 = unsafe { ::std::mem::transmute(non_root) };
            non_root as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: async paging."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " The updated CR3 value.\n\n The lower 5 bit have been zeroed out.\n The upper bits have been zeroed out depending on the\n maximum possible address."]
    pub cr3: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The address at which the event is effective."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_6>() - 24usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_6>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_6::cr3"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_6, cr3) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_6::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_6, ip) - 16usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_6 {
    #[inline]
    pub fn non_root(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_root(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(non_root: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let non_root: u32 = unsafe { ::std::mem::transmute(non_root) };
            non_root as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: overflow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_7 {
    #[doc = " The address at which tracing resumes after overflow.\n\n This field is not valid, if ip_suppressed is set.\n In this case, the overflow resolved while tracing\n was disabled."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_7::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_7, ip) - 0usize];
};
#[doc = " Event: exec mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_8 {
    #[doc = " The execution mode."]
    pub mode: pt_exec_mode,
    #[doc = " The address at which the event is effective."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_8"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_8>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_8"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_8>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_8::mode"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_8, mode) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_8::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_8, ip) - 8usize];
};
#[doc = " Event: tsx."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_9 {
    #[doc = " The address at which the event is effective.\n\n This field is not valid if \\@ip_suppressed is set."]
    pub ip: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_9"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_9>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_9"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_9>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_9::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_9, ip) - 0usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_9 {
    #[inline]
    pub fn speculative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_speculative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aborted(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aborted(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(speculative: u32, aborted: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let speculative: u32 = unsafe { ::std::mem::transmute(speculative) };
            speculative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let aborted: u32 = unsafe { ::std::mem::transmute(aborted) };
            aborted as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: vmcs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_10 {
    #[doc = " The VMCS base address.\n\n The address is zero-extended with the lower 12 bits\n all zero."]
    pub base: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_10"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_10>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_10"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_10>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_10::base"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_10, base) - 0usize];
};
#[doc = " Event: async vmcs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_11 {
    #[doc = " The VMCS base address.\n\n The address is zero-extended with the lower 12 bits\n all zero."]
    pub base: u64,
    #[doc = " The address at which the event is effective."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_11"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_11>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_11"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_11>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_11::base"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_11, base) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_11::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_11, ip) - 8usize];
};
#[doc = " Event: execution stopped."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_12 {
    #[doc = " The address at which execution has stopped.  This is\n the last instruction that did not complete.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_12"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_12>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_12"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_12>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_12::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_12, ip) - 0usize];
};
#[doc = " Event: mwait."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_13 {
    #[doc = " The address of the instruction causing the mwait.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
    #[doc = " The mwait hints (eax).\n\n Reserved bits are undefined."]
    pub hints: u32,
    #[doc = " The mwait extensions (ecx).\n\n Reserved bits are undefined."]
    pub ext: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_13"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_13>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_13"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_13>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_13::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_13, ip) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_13::hints"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_13, hints) - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_13::ext"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_13, ext) - 12usize];
};
#[doc = " Event: power state entry."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_14 {
    #[doc = " The resolved thread C-state."]
    pub state: u8,
    #[doc = " The resolved thread sub C-state."]
    pub sub_state: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_14"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_14>() - 4usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_14"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_14>() - 4usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_14::state"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_14, state) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_14::sub_state"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_14, sub_state) - 1usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_14 {
    #[inline]
    pub fn hw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hw: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw: u32 = unsafe { ::std::mem::transmute(hw) };
            hw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: power state exit."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_15 {
    #[doc = " The core C-state at the time of the wake."]
    pub last: u8,
    #[doc = " The deepest core C-state achieved during sleep."]
    pub deepest: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_15"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_15>() - 4usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_15"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_15>() - 4usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_15::last"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_15, last) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_15::deepest"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_15, deepest) - 1usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_15 {
    #[inline]
    pub fn interrupt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interrupt: u32,
        store: u32,
        autonomous: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt: u32 = unsafe { ::std::mem::transmute(interrupt) };
            interrupt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let store: u32 = unsafe { ::std::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: ptwrite."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_16 {
    #[doc = " The address of the ptwrite instruction.\n\n This field is not valid, if \\@ip_suppressed is set.\n\n In this case, the address is obvious from the\n disassembly."]
    pub ip: u64,
    #[doc = " The size of the below \\@payload in bytes."]
    pub size: u8,
    #[doc = " The ptwrite payload."]
    pub payload: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_16"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_16>() - 24usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_16"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_16>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_16::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_16, ip) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_16::size"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_16, size) - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_16::payload"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_16, payload) - 16usize];
};
#[doc = " Event: tick."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_17 {
    #[doc = " The instruction address near which the tick\n  occurred.\n\n A timestamp can sometimes be attributed directly to\n an instruction (e.g. to an indirect branch that\n receives CYC + TIP) and sometimes not (e.g. MTC).\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_17"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_17>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_17"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_17>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_17::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_17, ip) - 0usize];
};
#[doc = " Event: cbr."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_18 {
    #[doc = " The core:bus ratio."]
    pub ratio: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_18"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_18>() - 2usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_18"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_18>() - 2usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_18::ratio"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_18, ratio) - 0usize];
};
#[doc = " Event: mnt."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_19 {
    #[doc = " The raw payload."]
    pub payload: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_19"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_19>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_19"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_19>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_19::payload"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_19, payload) - 0usize];
};
#[doc = " Event: tip."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_20 {
    #[doc = " The target instruction address."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_20"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_20>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_20"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_20>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_20::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_20, ip) - 0usize];
};
#[doc = " Event: tnt."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_21 {
    #[doc = " A sequence of conditional branch indicator bits.\n\n Indicators are ordered from oldest (bits[size-1]) to\n youngest (bits[0]) branch:\n\n   0...branch not taken\n   1...branch taken"]
    pub bits: u64,
    #[doc = " The number of valid bits in @bits."]
    pub size: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_21"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_21>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_21"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_21>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_21::bits"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_21, bits) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_21::size"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_21, size) - 8usize];
};
#[doc = " Event: iflags."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_22 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The address of the instruction at which the new\n status applies.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_22"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_22>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_22"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_22>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_22::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_22, ip) - 8usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_22 {
    #[inline]
    pub fn iflag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iflag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(iflag: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iflag: u32 = unsafe { ::std::mem::transmute(iflag) };
            iflag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: interrupt/exception."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_23 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The interrupt/exception vector."]
    pub vector: u8,
    #[doc = " The page fault linear address in cr2.\n\n This field is only valid if \\@has_cr2 is set."]
    pub cr2: u64,
    #[doc = " The address of the instruction at which the\n interrupt or exception occurred.\n\n For faults, this will be the faulting instruction.\n For traps, this will be the next instruction.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_23"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_23>() - 24usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_23"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_23>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_23::vector"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_23, vector) - 1usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_23::cr2"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_23, cr2) - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_23::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_23, ip) - 16usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_23 {
    #[inline]
    pub fn has_cr2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_cr2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_cr2: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_cr2: u32 = unsafe { ::std::mem::transmute(has_cr2) };
            has_cr2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: iret."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_24 {
    #[doc = " The address of the instruction.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_24"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_24>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_24"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_24>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_24::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_24, ip) - 0usize];
};
#[doc = " Event: smi."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_25 {
    #[doc = " The address of the instruction at/before which the\n system management interrupt occurred.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_25"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_25>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_25"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_25>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_25::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_25, ip) - 0usize];
};
#[doc = " Event: rsm."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_26 {
    #[doc = " The address of the instruction.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_26"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_26>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_26"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_26>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_26::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_26, ip) - 0usize];
};
#[doc = " Event: sipi."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_27 {
    #[doc = " The SIPI vector."]
    pub vector: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_27"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_27>() - 1usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_27"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_27>() - 1usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_27::vector"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_27, vector) - 0usize];
};
#[doc = " Event: init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_28 {
    #[doc = " The address of the instruction.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_28"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_28>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_28"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_28>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_28::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_28, ip) - 0usize];
};
#[doc = " Event: vmentry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_29 {
    #[doc = " The address of the instruction.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_29"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_29>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_29"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_29>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_29::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_29, ip) - 0usize];
};
#[doc = " Event: vmexit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_30 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " The interrupt/exception vector.\n\n This field is only valid if \\@has_vector is set."]
    pub vector: u8,
    #[doc = " The vmexit reason.\n\n This field is only valid if \\@has_vmxr is set."]
    pub vmxr: u64,
    #[doc = " The vmexit qualification.\n\n This field is only valid if \\@has_vmxq is set."]
    pub vmxq: u64,
    #[doc = " The address of the instruction at which the\n interrupt or exception occurred.\n\n For faults, this will be the faulting instruction.\n For traps, this will be the next instruction.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_30"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_30>() - 32usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_30"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_30>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_30::vector"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_30, vector) - 1usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_30::vmxr"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_30, vmxr) - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_30::vmxq"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_30, vmxq) - 16usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_30::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_30, ip) - 24usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_30 {
    #[inline]
    pub fn has_vector(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_vector(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_vmxr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_vmxr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_vmxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_vmxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_vector: u32,
        has_vmxr: u32,
        has_vmxq: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_vector: u32 = unsafe { ::std::mem::transmute(has_vector) };
            has_vector as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_vmxr: u32 = unsafe { ::std::mem::transmute(has_vmxr) };
            has_vmxr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_vmxq: u32 = unsafe { ::std::mem::transmute(has_vmxq) };
            has_vmxq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Event: shutdown."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_31 {
    #[doc = " The address of the first instruction that did not\n complete due to the shutdown.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_31"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_31>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_31"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_31>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_31::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_31, ip) - 0usize];
};
#[doc = " Event: user interrupt."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_32 {
    #[doc = " The user interrupt vector."]
    pub vector: u8,
    #[doc = " The address of the instruction before which the\n user interrupt was delivered.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_32"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_32>() - 16usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_32"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_32>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_32::vector"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_32, vector) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_32::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_32, ip) - 8usize];
};
#[doc = " Event: uiret."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_33 {
    #[doc = " The address of the instruction.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_33"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_33>() - 8usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_33"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_33>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_33::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_33, ip) - 0usize];
};
#[doc = " Event: trigger."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_event__bindgen_ty_1__bindgen_ty_34 {
    #[doc = " A bit vector of triggers represented by this event.\n\n Triggers are configured via IA32_RTIT_TRIGGERx_CFG."]
    pub trbv: u8,
    #[doc = " The number of instructions after the anchor.\n\n The insn and block decoders will attempty to reduce\n \\@icount to zero and update \\@ip.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub icnt: u16,
    #[doc = " The address of the anchor instruction.\n\n If this field is zero, use the address of the last\n trig, tip, tip.pge, or async event, or the address\n after applying the final bit in the last tnt event.\n\n The insn and block decoders will supply a non-zero\n address or set \\@ip_suppressed.\n\n The event is reported when reaching the instruction\n address before the instruction itself to correctly\n handle cases where the instruction faults.\n\n This field is not valid, if \\@ip_suppressed is set."]
    pub ip: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1__bindgen_ty_34"]
        [::std::mem::size_of::<pt_event__bindgen_ty_1__bindgen_ty_34>() - 24usize];
    ["Alignment of pt_event__bindgen_ty_1__bindgen_ty_34"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1__bindgen_ty_34>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_34::trbv"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_34, trbv) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_34::icnt"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_34, icnt) - 2usize];
    ["Offset of field: pt_event__bindgen_ty_1__bindgen_ty_34::ip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1__bindgen_ty_34, ip) - 8usize];
};
impl pt_event__bindgen_ty_1__bindgen_ty_34 {
    #[inline]
    pub fn mult(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mult(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mult: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mult: u32 = unsafe { ::std::mem::transmute(mult) };
            mult as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event__bindgen_ty_1"][::std::mem::size_of::<pt_event__bindgen_ty_1>() - 32usize];
    ["Alignment of pt_event__bindgen_ty_1"]
        [::std::mem::align_of::<pt_event__bindgen_ty_1>() - 8usize];
    ["Offset of field: pt_event__bindgen_ty_1::enabled"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, enabled) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::disabled"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, disabled) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::async_disabled"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, async_disabled) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::async_branch"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, async_branch) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::paging"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, paging) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::async_paging"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, async_paging) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::overflow"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, overflow) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::exec_mode"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, exec_mode) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::tsx"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, tsx) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::vmcs"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, vmcs) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::async_vmcs"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, async_vmcs) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::exstop"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, exstop) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::mwait"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, mwait) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::pwre"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, pwre) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::pwrx"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, pwrx) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::ptwrite"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, ptwrite) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::tick"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, tick) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::cbr"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, cbr) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::mnt"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, mnt) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::tip"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, tip) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::tnt"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, tnt) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::iflags"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, iflags) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::interrupt"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, interrupt) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::iret"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, iret) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::smi"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, smi) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::rsm"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, rsm) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::sipi"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, sipi) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::init"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, init) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::vmentry"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, vmentry) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::vmexit"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, vmexit) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::shutdown"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, shutdown) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::uintr"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, uintr) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::uiret"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, uiret) - 0usize];
    ["Offset of field: pt_event__bindgen_ty_1::trig"]
        [::std::mem::offset_of!(pt_event__bindgen_ty_1, trig) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_event"][::std::mem::size_of::<pt_event>() - 72usize];
    ["Alignment of pt_event"][::std::mem::align_of::<pt_event>() - 8usize];
    ["Offset of field: pt_event::type_"][::std::mem::offset_of!(pt_event, type_) - 0usize];
    ["Offset of field: pt_event::tsc"][::std::mem::offset_of!(pt_event, tsc) - 8usize];
    ["Offset of field: pt_event::lost_mtc"][::std::mem::offset_of!(pt_event, lost_mtc) - 16usize];
    ["Offset of field: pt_event::lost_cyc"][::std::mem::offset_of!(pt_event, lost_cyc) - 20usize];
    ["Offset of field: pt_event::reserved"][::std::mem::offset_of!(pt_event, reserved) - 24usize];
    ["Offset of field: pt_event::variant"][::std::mem::offset_of!(pt_event, variant) - 40usize];
};
impl pt_event {
    #[inline]
    pub fn ip_suppressed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip_suppressed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn status_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_status_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_tsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_tsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ip_suppressed: u32,
        status_update: u32,
        has_tsc: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip_suppressed: u32 = unsafe { ::std::mem::transmute(ip_suppressed) };
            ip_suppressed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let status_update: u32 = unsafe { ::std::mem::transmute(status_update) };
            status_update as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_tsc: u32 = unsafe { ::std::mem::transmute(has_tsc) };
            has_tsc as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Allocate an Intel PT event decoder.\n\n The decoder will work on the buffer defined in \\@config, it shall contain\n raw trace data and remain valid for the lifetime of the decoder.\n\n The decoder needs to be synchronized before it can be used."]
    pub fn pt_evt_alloc_decoder(config: *const pt_config) -> *mut pt_event_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT event decoder.\n\n The \\@decoder must not be used after a successful return."]
    pub fn pt_evt_free_decoder(decoder: *mut pt_event_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT event decoder.\n\n Search for the next synchronization point in forward or backward direction.\n\n If \\@decoder has not been synchronized, yet, the search is started at the\n beginning of the trace buffer in case of forward synchronization and at the\n end of the trace buffer in case of backward synchronization.\n\n Returns zero or a positive value on success, a negative error code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if no further synchronization point is found.\n Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_evt_sync_forward(decoder: *mut pt_event_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_evt_sync_backward(decoder: *mut pt_event_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Manually synchronize an Intel PT event decoder.\n\n Synchronize \\@decoder on the syncpoint at \\@offset.  There must be a PSB\n packet at \\@offset.\n\n Returns zero or a positive value on success, a negative error code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if \\@offset lies outside of \\@decoder's trace buffer.\n Returns -pte_eos if \\@decoder reaches the end of its trace buffer.\n Returns -pte_invalid if \\@decoder is NULL.\n Returns -pte_nosync if there is no syncpoint at \\@offset."]
    pub fn pt_evt_sync_set(decoder: *mut pt_event_decoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position.\n\n Fills the current \\@decoder position into \\@offset.\n\n This is useful for reporting errors.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_evt_get_offset(
        decoder: *const pt_event_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point.\n\n Fills the last synchronization position into \\@offset.\n\n This is useful for splitting a trace stream for parallel decoding.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_evt_get_sync_offset(
        decoder: *const pt_event_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_evt_get_config(decoder: *const pt_event_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Determine the next event.\n\n On success, provides the next event in \\@event.\n\n The \\@size argument must be set to sizeof(struct pt_event).\n\n Returns zero or a positive value on success, a negative error code\n otherwise.\n\n Returns -pte_bad_opc if the packet is unknown.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if \\@decoder reached the end of the Intel PT buffer.\n Returns -pte_invalid if \\@decoder or \\@event is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_evt_next(
        decoder: *mut pt_event_decoder,
        event: *mut pt_event,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " There is an event pending."]
pub const pt_status_flag_pts_event_pending: pt_status_flag = 1;
#[doc = " The address has been suppressed."]
pub const pt_status_flag_pts_ip_suppressed: pt_status_flag = 2;
#[doc = " There is no more trace data available."]
pub const pt_status_flag_pts_eos: pt_status_flag = 4;
#[doc = " Decoder status flags."]
pub type pt_status_flag = i32;
extern "C" {
    #[doc = " Allocate an Intel PT query decoder.\n\n The decoder will work on the buffer defined in \\@config, it shall contain\n raw trace data and remain valid for the lifetime of the decoder.\n\n The decoder needs to be synchronized before it can be used."]
    pub fn pt_qry_alloc_decoder(config: *const pt_config) -> *mut pt_query_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT query decoder.\n\n The \\@decoder must not be used after a successful return."]
    pub fn pt_qry_free_decoder(decoder: *mut pt_query_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT query decoder.\n\n Search for the next synchronization point in forward or backward direction.\n\n If \\@decoder has not been synchronized, yet, the search is started at the\n beginning of the trace buffer in case of forward synchronization and at the\n end of the trace buffer in case of backward synchronization.\n\n If \\@ip is not NULL, set it to last ip.\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if no further synchronization point is found.\n Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_qry_sync_forward(
        decoder: *mut pt_query_decoder,
        ip: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_qry_sync_backward(
        decoder: *mut pt_query_decoder,
        ip: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Manually synchronize an Intel PT query decoder.\n\n Synchronize \\@decoder on the syncpoint at \\@offset.  There must be a PSB\n packet at \\@offset.\n\n If \\@ip is not NULL, set it to last ip.\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if \\@offset lies outside of \\@decoder's trace buffer.\n Returns -pte_eos if \\@decoder reaches the end of its trace buffer.\n Returns -pte_invalid if \\@decoder is NULL.\n Returns -pte_nosync if there is no syncpoint at \\@offset."]
    pub fn pt_qry_sync_set(
        decoder: *mut pt_query_decoder,
        ip: *mut u64,
        offset: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position.\n\n Fills the current \\@decoder position into \\@offset.\n\n This is useful for reporting errors.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_get_offset(
        decoder: *const pt_query_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point.\n\n Fills the last synchronization position into \\@offset.\n\n This is useful for splitting a trace stream for parallel decoding.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_get_sync_offset(
        decoder: *const pt_query_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_qry_get_config(decoder: *const pt_query_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Query whether the next unconditional branch has been taken.\n\n On success, provides 1 (taken) or 0 (not taken) in \\@taken for the next\n conditional branch and updates \\@decoder.\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_bad_query if no conditional branch is found.\n Returns -pte_eos if decoding reached the end of the Intel PT buffer.\n Returns -pte_invalid if \\@decoder or \\@taken is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_cond_branch(
        decoder: *mut pt_query_decoder,
        taken: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next indirect branch destination.\n\n On success, provides the linear destination address of the next indirect\n branch in \\@ip and updates \\@decoder.\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_bad_query if no indirect branch is found.\n Returns -pte_eos if decoding reached the end of the Intel PT buffer.\n Returns -pte_invalid if \\@decoder or \\@ip is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_indirect_branch(
        decoder: *mut pt_query_decoder,
        ip: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the next pending event.\n\n On success, provides the next event \\@event and updates \\@decoder.\n\n The \\@size argument must be set to sizeof(struct pt_event).\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_bad_query if no event is found.\n Returns -pte_eos if decoding reached the end of the Intel PT buffer.\n Returns -pte_invalid if \\@decoder or \\@event is NULL.\n Returns -pte_invalid if \\@size is too small.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_qry_event(
        decoder: *mut pt_query_decoder,
        event: *mut pt_event,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the current time.\n\n On success, provides the time at the last query in \\@time.\n\n The time is similar to what a rdtsc instruction would return.  Depending\n on the configuration, the time may not be fully accurate.  If TSC is not\n enabled, the time is relative to the last synchronization and can't be used\n to correlate with other TSC-based time sources.  In this case, -pte_no_time\n is returned and the relative time is provided in \\@time.\n\n Some timing-related packets may need to be dropped (mostly due to missing\n calibration or incomplete configuration).  To get an idea about the quality\n of the estimated time, we record the number of dropped MTC and CYC packets.\n\n If \\@lost_mtc is not NULL, set it to the number of lost MTC packets.\n If \\@lost_cyc is not NULL, set it to the number of lost CYC packets.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@time is NULL.\n Returns -pte_no_time if there has not been a TSC packet."]
    pub fn pt_qry_time(
        decoder: *mut pt_query_decoder,
        time: *mut u64,
        lost_mtc: *mut u32,
        lost_cyc: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current core bus ratio.\n\n On success, provides the current core:bus ratio in \\@cbr.  The ratio is\n defined as core cycles per bus clock cycle.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@cbr is NULL.\n Returns -pte_no_cbr if there has not been a CBR packet."]
    pub fn pt_qry_core_bus_ratio(
        decoder: *mut pt_query_decoder,
        cbr: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " An Intel PT address space identifier.\n\n This identifies a particular address space when adding file sections or\n when reading memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_asid {
    #[doc = " The size of this object - set to sizeof(struct pt_asid)."]
    pub size: usize,
    #[doc = " The CR3 value."]
    pub cr3: u64,
    #[doc = " The VMCS Base address."]
    pub vmcs: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_asid"][::std::mem::size_of::<pt_asid>() - 24usize];
    ["Alignment of pt_asid"][::std::mem::align_of::<pt_asid>() - 8usize];
    ["Offset of field: pt_asid::size"][::std::mem::offset_of!(pt_asid, size) - 0usize];
    ["Offset of field: pt_asid::cr3"][::std::mem::offset_of!(pt_asid, cr3) - 8usize];
    ["Offset of field: pt_asid::vmcs"][::std::mem::offset_of!(pt_asid, vmcs) - 16usize];
};
#[doc = " An unknown CR3 value to be used for pt_asid objects."]
pub const pt_asid_no_cr3: u64 = 18446744073709551615;
#[doc = " An unknown VMCS Base value to be used for pt_asid objects."]
pub const pt_asid_no_vmcs: u64 = 18446744073709551615;
#[doc = " A cache of traced image sections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_image_section_cache {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a traced memory image section cache.\n\n An optional \\@name may be given to the cache.  The name string is copied.\n\n Returns a new traced memory image section cache on success, NULL otherwise."]
    pub fn pt_iscache_alloc(name: *const ::std::os::raw::c_char) -> *mut pt_image_section_cache;
}
extern "C" {
    #[doc = " Free a traced memory image section cache.\n\n The \\@iscache must have been allocated with pt_iscache_alloc().\n The \\@iscache must not be used after a successful return."]
    pub fn pt_iscache_free(iscache: *mut pt_image_section_cache);
}
extern "C" {
    #[doc = " Set the image section cache limit.\n\n Set the limit for a section cache in bytes.  A non-zero limit will keep the\n least recently used sections mapped until the limit is reached.  A limit of\n zero disables caching.\n\n Returns zero on success, a negative pt_error_code otherwise.\n Returns -pte_invalid if \\@iscache is NULL."]
    pub fn pt_iscache_set_limit(
        iscache: *mut pt_image_section_cache,
        limit: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the image section cache name.\n\n Returns a pointer to \\@iscache's name or NULL if there is no name."]
    pub fn pt_iscache_name(iscache: *const pt_image_section_cache)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add a new file section to the traced memory image section cache.\n\n Adds a new section consisting of \\@size bytes starting at \\@offset in\n \\@filename loaded at the virtual address \\@vaddr if \\@iscache does not\n already contain such a section.\n\n Returns an image section identifier (isid) uniquely identifying that section\n in \\@iscache.\n\n The section is silently truncated to match the size of \\@filename.\n\n Returns a positive isid on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@iscache or \\@filename is NULL.\n Returns -pte_invalid if \\@offset is too big."]
    pub fn pt_iscache_add_file(
        iscache: *mut pt_image_section_cache,
        filename: *const ::std::os::raw::c_char,
        offset: u64,
        size: u64,
        vaddr: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read memory from a cached file section\n\n Reads \\@size bytes of memory starting at virtual address \\@vaddr in the\n section identified by \\@isid in \\@iscache into \\@buffer.\n\n The caller is responsible for allocating a \\@buffer of at least \\@size bytes.\n\n The read request may be truncated if it crosses section boundaries or if\n \\@size is getting too big.  We support reading at least 4Kbyte in one chunk\n unless the read would cross a section boundary.\n\n Returns the number of bytes read on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@iscache or \\@buffer is NULL.\n Returns -pte_invalid if \\@size is zero.\n Returns -pte_nomap if \\@vaddr is not contained in section \\@isid.\n Returns -pte_bad_image if \\@iscache does not contain \\@isid."]
    pub fn pt_iscache_read(
        iscache: *mut pt_image_section_cache,
        buffer: *mut u8,
        size: u64,
        isid: ::std::os::raw::c_int,
        vaddr: u64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The traced memory image."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_image {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a traced memory image.\n\n An optional \\@name may be given to the image.  The name string is copied.\n\n Returns a new traced memory image on success, NULL otherwise."]
    pub fn pt_image_alloc(name: *const ::std::os::raw::c_char) -> *mut pt_image;
}
extern "C" {
    #[doc = " Free a traced memory image.\n\n The \\@image must have been allocated with pt_image_alloc().\n The \\@image must not be used after a successful return."]
    pub fn pt_image_free(image: *mut pt_image);
}
extern "C" {
    #[doc = " Get the image name.\n\n Returns a pointer to \\@image's name or NULL if there is no name."]
    pub fn pt_image_name(image: *const pt_image) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add a new file section to the traced memory image.\n\n Adds \\@size bytes starting at \\@offset in \\@filename. The section is\n loaded at the virtual address \\@vaddr in the address space \\@asid.\n\n The \\@asid may be NULL or (partially) invalid.  In that case only the valid\n fields are considered when comparing with other address-spaces.  Use this\n when tracing a single process or when adding sections to all processes.\n\n The section is silently truncated to match the size of \\@filename.\n\n Existing sections that would overlap with the new section will be shrunk\n or split.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@image or \\@filename is NULL.\n Returns -pte_invalid if \\@offset is too big."]
    pub fn pt_image_add_file(
        image: *mut pt_image,
        filename: *const ::std::os::raw::c_char,
        offset: u64,
        size: u64,
        asid: *const pt_asid,
        vaddr: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a section from an image section cache.\n\n Add the section from \\@iscache identified by \\@isid in address space \\@asid.\n\n Existing sections that would overlap with the new section will be shrunk\n or split.\n\n Returns zero on success, a negative error code otherwise.\n Returns -pte_invalid if \\@image or \\@iscache is NULL.\n Returns -pte_bad_image if \\@iscache does not contain \\@isid."]
    pub fn pt_image_add_cached(
        image: *mut pt_image,
        iscache: *mut pt_image_section_cache,
        isid: ::std::os::raw::c_int,
        asid: *const pt_asid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy an image.\n\n Adds all sections from \\@src to \\@image.  Sections that could not be added\n will be ignored.\n\n Returns the number of ignored sections on success, a negative error code\n otherwise.\n\n Returns -pte_invalid if \\@image or \\@src is NULL."]
    pub fn pt_image_copy(image: *mut pt_image, src: *const pt_image) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all sections loaded from a file.\n\n Removes all sections loaded from \\@filename from the address space \\@asid.\n Specify the same \\@asid that was used for adding sections from \\@filename.\n\n Returns the number of removed sections on success, a negative error code\n otherwise.\n\n Returns -pte_invalid if \\@image or \\@filename is NULL."]
    pub fn pt_image_remove_by_filename(
        image: *mut pt_image,
        filename: *const ::std::os::raw::c_char,
        asid: *const pt_asid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all sections loaded into an address space.\n\n Removes all sections loaded into \\@asid.  Specify the same \\@asid that was\n used for adding sections.\n\n Returns the number of removed sections on success, a negative error code\n otherwise.\n\n Returns -pte_invalid if \\@image is NULL."]
    pub fn pt_image_remove_by_asid(
        image: *mut pt_image,
        asid: *const pt_asid,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A read memory callback function.\n\n It shall read \\@size bytes of memory from address space \\@asid starting\n at \\@ip into \\@buffer.\n\n It shall return the number of bytes read on success.\n It shall return a negative pt_error_code otherwise."]
pub type read_memory_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut u8,
        size: usize,
        asid: *const pt_asid,
        ip: u64,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Set the memory callback for the traced memory image.\n\n Sets \\@callback for reading memory.  The callback is used for addresses\n that are not found in file sections.  The \\@context argument is passed\n to \\@callback on each use.\n\n There can only be one callback at any time.  A subsequent call will replace\n the previous callback.  If \\@callback is NULL, the callback is removed.\n\n Returns -pte_invalid if \\@image is NULL."]
    pub fn pt_image_set_callback(
        image: *mut pt_image,
        callback: read_memory_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const pt_insn_class_ptic_unknown: pt_insn_class = 0;
pub const pt_insn_class_ptic_error: pt_insn_class = 0;
pub const pt_insn_class_ptic_other: pt_insn_class = 1;
pub const pt_insn_class_ptic_call: pt_insn_class = 2;
pub const pt_insn_class_ptic_return: pt_insn_class = 3;
pub const pt_insn_class_ptic_jump: pt_insn_class = 4;
pub const pt_insn_class_ptic_cond_jump: pt_insn_class = 5;
pub const pt_insn_class_ptic_far_call: pt_insn_class = 6;
pub const pt_insn_class_ptic_far_return: pt_insn_class = 7;
pub const pt_insn_class_ptic_far_jump: pt_insn_class = 8;
pub const pt_insn_class_ptic_ptwrite: pt_insn_class = 9;
pub const pt_insn_class_ptic_indirect: pt_insn_class = 10;
#[doc = " The instruction class.\n\n We provide only a very coarse classification suitable for reconstructing\n the execution flow."]
pub type pt_insn_class = i32;
pub const pt_max_insn_size: _bindgen_ty_1 = 15;
#[doc = " The maximal size of an instruction."]
pub type _bindgen_ty_1 = i32;
#[doc = " A single traced instruction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_insn {
    #[doc = " The virtual address in its process."]
    pub ip: u64,
    #[doc = " The image section identifier for the section containing this\n instruction.\n\n A value of zero means that the section did not have an identifier.\n The section was not added via an image section cache or the memory\n was read via the read memory callback."]
    pub isid: ::std::os::raw::c_int,
    #[doc = " The execution mode."]
    pub mode: pt_exec_mode,
    #[doc = " A coarse classification."]
    pub iclass: pt_insn_class,
    #[doc = " The raw bytes."]
    pub raw: [u8; 15usize],
    #[doc = " The size in bytes."]
    pub size: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_insn"][::std::mem::size_of::<pt_insn>() - 40usize];
    ["Alignment of pt_insn"][::std::mem::align_of::<pt_insn>() - 8usize];
    ["Offset of field: pt_insn::ip"][::std::mem::offset_of!(pt_insn, ip) - 0usize];
    ["Offset of field: pt_insn::isid"][::std::mem::offset_of!(pt_insn, isid) - 8usize];
    ["Offset of field: pt_insn::mode"][::std::mem::offset_of!(pt_insn, mode) - 12usize];
    ["Offset of field: pt_insn::iclass"][::std::mem::offset_of!(pt_insn, iclass) - 16usize];
    ["Offset of field: pt_insn::raw"][::std::mem::offset_of!(pt_insn, raw) - 20usize];
    ["Offset of field: pt_insn::size"][::std::mem::offset_of!(pt_insn, size) - 35usize];
};
impl pt_insn {
    #[inline]
    pub fn speculative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_speculative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn truncated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_truncated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(speculative: u32, truncated: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let speculative: u32 = unsafe { ::std::mem::transmute(speculative) };
            speculative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let truncated: u32 = unsafe { ::std::mem::transmute(truncated) };
            truncated as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Allocate an Intel PT instruction flow decoder.\n\n The decoder will work on the buffer defined in \\@config, it shall contain\n raw trace data and remain valid for the lifetime of the decoder.\n\n The decoder needs to be synchronized before it can be used."]
    pub fn pt_insn_alloc_decoder(config: *const pt_config) -> *mut pt_insn_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT instruction flow decoder.\n\n This will destroy the decoder's default image.\n\n The \\@decoder must not be used after a successful return."]
    pub fn pt_insn_free_decoder(decoder: *mut pt_insn_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT instruction flow decoder.\n\n Search for the next synchronization point in forward or backward direction.\n\n If \\@decoder has not been synchronized, yet, the search is started at the\n beginning of the trace buffer in case of forward synchronization and at the\n end of the trace buffer in case of backward synchronization.\n\n Returns zero or a positive value on success, a negative error code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if no further synchronization point is found.\n Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_insn_sync_forward(decoder: *mut pt_insn_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_insn_sync_backward(decoder: *mut pt_insn_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Manually synchronize an Intel PT instruction flow decoder.\n\n Synchronize \\@decoder on the syncpoint at \\@offset.  There must be a PSB\n packet at \\@offset.\n\n Returns zero or a positive value on success, a negative error code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if \\@offset lies outside of \\@decoder's trace buffer.\n Returns -pte_eos if \\@decoder reaches the end of its trace buffer.\n Returns -pte_invalid if \\@decoder is NULL.\n Returns -pte_nosync if there is no syncpoint at \\@offset."]
    pub fn pt_insn_sync_set(decoder: *mut pt_insn_decoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position.\n\n Fills the current \\@decoder position into \\@offset.\n\n This is useful for reporting errors.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_insn_get_offset(
        decoder: *const pt_insn_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point.\n\n Fills the last synchronization position into \\@offset.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_insn_get_sync_offset(
        decoder: *const pt_insn_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the traced image.\n\n The returned image may be modified as long as no decoder that uses this\n image is running.\n\n Returns a pointer to the traced image the decoder uses for reading memory.\n Returns NULL if \\@decoder is NULL."]
    pub fn pt_insn_get_image(decoder: *mut pt_insn_decoder) -> *mut pt_image;
}
extern "C" {
    #[doc = " Set the traced image.\n\n Sets the image that \\@decoder uses for reading memory to \\@image.  If \\@image\n is NULL, sets the image to \\@decoder's default image.\n\n Only one image can be active at any time.\n\n Returns zero on success, a negative error code otherwise.\n Return -pte_invalid if \\@decoder is NULL."]
    pub fn pt_insn_set_image(
        decoder: *mut pt_insn_decoder,
        image: *mut pt_image,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_insn_get_config(decoder: *const pt_insn_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Return the current time.\n\n On success, provides the time at the last preceding timing packet in \\@time.\n\n The time is similar to what a rdtsc instruction would return.  Depending\n on the configuration, the time may not be fully accurate.  If TSC is not\n enabled, the time is relative to the last synchronization and can't be used\n to correlate with other TSC-based time sources.  In this case, -pte_no_time\n is returned and the relative time is provided in \\@time.\n\n Some timing-related packets may need to be dropped (mostly due to missing\n calibration or incomplete configuration).  To get an idea about the quality\n of the estimated time, we record the number of dropped MTC and CYC packets.\n\n If \\@lost_mtc is not NULL, set it to the number of lost MTC packets.\n If \\@lost_cyc is not NULL, set it to the number of lost CYC packets.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@time is NULL.\n Returns -pte_no_time if there has not been a TSC packet."]
    pub fn pt_insn_time(
        decoder: *mut pt_insn_decoder,
        time: *mut u64,
        lost_mtc: *mut u32,
        lost_cyc: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current core bus ratio.\n\n On success, provides the current core:bus ratio in \\@cbr.  The ratio is\n defined as core cycles per bus clock cycle.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@cbr is NULL.\n Returns -pte_no_cbr if there has not been a CBR packet."]
    pub fn pt_insn_core_bus_ratio(
        decoder: *mut pt_insn_decoder,
        cbr: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current address space identifier.\n\n On success, provides the current address space identifier in \\@asid.\n\n The \\@size argument must be set to sizeof(struct pt_asid).  At most \\@size\n bytes will be copied and \\@asid->size will be set to the actual size of the\n provided address space identifier.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@asid is NULL."]
    pub fn pt_insn_asid(
        decoder: *const pt_insn_decoder,
        asid: *mut pt_asid,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the next instruction.\n\n On success, provides the next instruction in execution order in \\@insn.\n\n The \\@size argument must be set to sizeof(struct pt_insn).\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns pts_eos to indicate the end of the trace stream.  Subsequent calls\n to pt_insn_next() will continue to return pts_eos until trace is required\n to determine the next instruction.\n\n Returns -pte_bad_context if the decoder encountered an unexpected packet.\n Returns -pte_bad_opc if the decoder encountered unknown packets.\n Returns -pte_bad_packet if the decoder encountered unknown packet payloads.\n Returns -pte_bad_query if the decoder got out of sync.\n Returns -pte_eos if decoding reached the end of the Intel PT buffer.\n Returns -pte_invalid if \\@decoder or \\@insn is NULL.\n Returns -pte_nomap if the memory at the instruction address can't be read.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_insn_next(
        decoder: *mut pt_insn_decoder,
        insn: *mut pt_insn,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next pending event.\n\n On success, provides the next event in \\@event and updates \\@decoder.\n\n The \\@size argument must be set to sizeof(struct pt_event).\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns -pte_bad_query if there is no event.\n Returns -pte_invalid if \\@decoder or \\@event is NULL.\n Returns -pte_invalid if \\@size is too small."]
    pub fn pt_insn_event(
        decoder: *mut pt_insn_decoder,
        event: *mut pt_event,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A block of instructions.\n\n Instructions in this block are executed sequentially but are not necessarily\n contiguous in memory.  Users are expected to follow direct branches."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_block {
    #[doc = " The IP of the first instruction in this block."]
    pub ip: u64,
    #[doc = " The IP of the last instruction in this block.\n\n This can be used for error-detection."]
    pub end_ip: u64,
    #[doc = " The image section that contains the instructions in this block.\n\n A value of zero means that the section did not have an identifier.\n The section was not added via an image section cache or the memory\n was read via the read memory callback."]
    pub isid: ::std::os::raw::c_int,
    #[doc = " The execution mode for all instructions in this block."]
    pub mode: pt_exec_mode,
    #[doc = " The instruction class for the last instruction in this block.\n\n This field may be set to ptic_unknown (ptic_error prior to v2.1) to\n indicate that the instruction class is not available.  The block\n decoder may choose to not provide the instruction class in some\n cases for performance reasons."]
    pub iclass: pt_insn_class,
    #[doc = " The number of instructions in this block."]
    pub ninsn: u16,
    #[doc = " The raw bytes of the last instruction in this block in case the\n instruction does not fit entirely into this block's section.\n\n This field is only valid if \\@truncated is set."]
    pub raw: [u8; 15usize],
    #[doc = " The size of the last instruction in this block in bytes.\n\n This field is only valid if \\@truncated is set."]
    pub size: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pt_block"][::std::mem::size_of::<pt_block>() - 48usize];
    ["Alignment of pt_block"][::std::mem::align_of::<pt_block>() - 8usize];
    ["Offset of field: pt_block::ip"][::std::mem::offset_of!(pt_block, ip) - 0usize];
    ["Offset of field: pt_block::end_ip"][::std::mem::offset_of!(pt_block, end_ip) - 8usize];
    ["Offset of field: pt_block::isid"][::std::mem::offset_of!(pt_block, isid) - 16usize];
    ["Offset of field: pt_block::mode"][::std::mem::offset_of!(pt_block, mode) - 20usize];
    ["Offset of field: pt_block::iclass"][::std::mem::offset_of!(pt_block, iclass) - 24usize];
    ["Offset of field: pt_block::ninsn"][::std::mem::offset_of!(pt_block, ninsn) - 28usize];
    ["Offset of field: pt_block::raw"][::std::mem::offset_of!(pt_block, raw) - 30usize];
    ["Offset of field: pt_block::size"][::std::mem::offset_of!(pt_block, size) - 45usize];
};
impl pt_block {
    #[inline]
    pub fn speculative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_speculative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn truncated(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_truncated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(speculative: u32, truncated: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let speculative: u32 = unsafe { ::std::mem::transmute(speculative) };
            speculative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let truncated: u32 = unsafe { ::std::mem::transmute(truncated) };
            truncated as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Allocate an Intel PT block decoder.\n\n The decoder will work on the buffer defined in \\@config, it shall contain\n raw trace data and remain valid for the lifetime of the decoder.\n\n The decoder needs to be synchronized before it can be used."]
    pub fn pt_blk_alloc_decoder(config: *const pt_config) -> *mut pt_block_decoder;
}
extern "C" {
    #[doc = " Free an Intel PT block decoder.\n\n This will destroy the decoder's default image.\n\n The \\@decoder must not be used after a successful return."]
    pub fn pt_blk_free_decoder(decoder: *mut pt_block_decoder);
}
extern "C" {
    #[doc = " Synchronize an Intel PT block decoder.\n\n Search for the next synchronization point in forward or backward direction.\n\n If \\@decoder has not been synchronized, yet, the search is started at the\n beginning of the trace buffer in case of forward synchronization and at the\n end of the trace buffer in case of backward synchronization.\n\n Returns zero or a positive value on success, a negative error code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if no further synchronization point is found.\n Returns -pte_invalid if \\@decoder is NULL."]
    pub fn pt_blk_sync_forward(decoder: *mut pt_block_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_blk_sync_backward(decoder: *mut pt_block_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Manually synchronize an Intel PT block decoder.\n\n Synchronize \\@decoder on the syncpoint at \\@offset.  There must be a PSB\n packet at \\@offset.\n\n Returns zero or a positive value on success, a negative error code otherwise.\n\n Returns -pte_bad_opc if an unknown packet is encountered.\n Returns -pte_bad_packet if an unknown packet payload is encountered.\n Returns -pte_eos if \\@offset lies outside of \\@decoder's trace buffer.\n Returns -pte_eos if \\@decoder reaches the end of its trace buffer.\n Returns -pte_invalid if \\@decoder is NULL.\n Returns -pte_nosync if there is no syncpoint at \\@offset."]
    pub fn pt_blk_sync_set(decoder: *mut pt_block_decoder, offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current decoder position.\n\n Fills the current \\@decoder position into \\@offset.\n\n This is useful for reporting errors.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_blk_get_offset(
        decoder: *const pt_block_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the last synchronization point.\n\n Fills the last synchronization position into \\@offset.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@offset is NULL.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_blk_get_sync_offset(
        decoder: *const pt_block_decoder,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the traced image.\n\n The returned image may be modified as long as \\@decoder is not running.\n\n Returns a pointer to the traced image \\@decoder uses for reading memory.\n Returns NULL if \\@decoder is NULL."]
    pub fn pt_blk_get_image(decoder: *mut pt_block_decoder) -> *mut pt_image;
}
extern "C" {
    #[doc = " Set the traced image.\n\n Sets the image that \\@decoder uses for reading memory to \\@image.  If \\@image\n is NULL, sets the image to \\@decoder's default image.\n\n Only one image can be active at any time.\n\n Returns zero on success, a negative error code otherwise.\n Return -pte_invalid if \\@decoder is NULL."]
    pub fn pt_blk_set_image(
        decoder: *mut pt_block_decoder,
        image: *mut pt_image,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pt_blk_get_config(decoder: *const pt_block_decoder) -> *const pt_config;
}
extern "C" {
    #[doc = " Return the current time.\n\n On success, provides the time at the last preceding timing packet in \\@time.\n\n The time is similar to what a rdtsc instruction would return.  Depending\n on the configuration, the time may not be fully accurate.  If TSC is not\n enabled, the time is relative to the last synchronization and can't be used\n to correlate with other TSC-based time sources.  In this case, -pte_no_time\n is returned and the relative time is provided in \\@time.\n\n Some timing-related packets may need to be dropped (mostly due to missing\n calibration or incomplete configuration).  To get an idea about the quality\n of the estimated time, we record the number of dropped MTC and CYC packets.\n\n If \\@lost_mtc is not NULL, set it to the number of lost MTC packets.\n If \\@lost_cyc is not NULL, set it to the number of lost CYC packets.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@time is NULL.\n Returns -pte_no_time if there has not been a TSC packet."]
    pub fn pt_blk_time(
        decoder: *mut pt_block_decoder,
        time: *mut u64,
        lost_mtc: *mut u32,
        lost_cyc: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current core bus ratio.\n\n On success, provides the current core:bus ratio in \\@cbr.  The ratio is\n defined as core cycles per bus clock cycle.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@cbr is NULL.\n Returns -pte_no_cbr if there has not been a CBR packet."]
    pub fn pt_blk_core_bus_ratio(
        decoder: *mut pt_block_decoder,
        cbr: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current address space identifier.\n\n On success, provides the current address space identifier in \\@asid.\n\n The \\@size argument must be set to sizeof(struct pt_asid).  At most \\@size\n bytes will be copied and \\@asid->size will be set to the actual size of the\n provided address space identifier.\n\n Returns zero on success, a negative error code otherwise.\n\n Returns -pte_invalid if \\@decoder or \\@asid is NULL."]
    pub fn pt_blk_asid(
        decoder: *const pt_block_decoder,
        asid: *mut pt_asid,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the next block of instructions.\n\n On success, provides the next block of instructions in execution order in\n \\@block.\n\n The \\@size argument must be set to sizeof(struct pt_block).\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns pts_eos to indicate the end of the trace stream.  Subsequent calls\n to pt_block_next() will continue to return pts_eos until trace is required\n to determine the next instruction.\n\n Returns -pte_bad_context if the decoder encountered an unexpected packet.\n Returns -pte_bad_opc if the decoder encountered unknown packets.\n Returns -pte_bad_packet if the decoder encountered unknown packet payloads.\n Returns -pte_bad_query if the decoder got out of sync.\n Returns -pte_eos if decoding reached the end of the Intel PT buffer.\n Returns -pte_invalid if \\@decoder or \\@block is NULL.\n Returns -pte_nomap if the memory at the instruction address can't be read.\n Returns -pte_nosync if \\@decoder is out of sync."]
    pub fn pt_blk_next(
        decoder: *mut pt_block_decoder,
        block: *mut pt_block,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next pending event.\n\n On success, provides the next event in \\@event and updates \\@decoder.\n\n The \\@size argument must be set to sizeof(struct pt_event).\n\n Returns a non-negative pt_status_flag bit-vector on success, a negative error\n code otherwise.\n\n Returns -pte_bad_query if there is no event.\n Returns -pte_invalid if \\@decoder or \\@event is NULL.\n Returns -pte_invalid if \\@size is too small."]
    pub fn pt_blk_event(
        decoder: *mut pt_block_decoder,
        event: *mut pt_event,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
